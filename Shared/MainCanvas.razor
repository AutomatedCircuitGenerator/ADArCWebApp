<div class="canvas-container" @onmousemove="DragMiddle" @onclick="CanvasClick" @onmousedown="DragStart" @onmouseup="DragEnd" @onmouseenter="handleMouseEnter" @onmouseleave="handleMouseLeave">
    @foreach (var c in comps)
    {
        <VaryingComponent forceBorder="c.Key == Pages.Index.App!.SelectedComponent" handleClick="e => ComponentSelection(e, c)" objId=@(c.Value.GlobalId) individualData=@c.Value DragStart="e => DragComponentStart(e, c)" DragEnd="DragComponentEnd" zoomFactor="@zoomFactor"></VaryingComponent>
    }


    <svg viewBox="0 0 @(Pages.Index.DefaultScreenWidth * Pages.Index.CurrentWidthRatio) @(Pages.Index.DefaultScreenHeight * Pages.Index.CurrentHeightRatio - 50)" xmlns="http://www.w3.org/2000/svg">
        @foreach (var line in ConnLines.Select((line, index) => (line, index)))
        {
            var gridLines = GetGridLines(line.line, 50, line.index * 5); // Example stepSize = 50 pixels
            foreach (var segment in gridLines)
            {
                <line x1="@segment.x1" y1="@segment.y1" x2="@segment.x2" y2="@segment.y2" stroke="@line.line.Color" stroke-width="@(3 * zoomFactor)"></line>
            }
        }
    </svg>


</div>

@code {

    public MainCanvas()
    {
        Pages.Index.BuildCanvas = this;
    }

    public readonly List<InstanceConnection> ConnLines = [];

    [Parameter] public required Dictionary<int, ComponentInstance> comps { get; set; }


    [Parameter] public EventCallback<MouseEventArgs> handleMouseLeave { get; set; }

    [Parameter] public EventCallback<MouseEventArgs> handleMouseEnter { get; set; }


    private bool _dragging = false;
    private bool _hasTarget = false; //refers to whether or not a drag process has a target, meaning that a component is dragged
    private KeyValuePair<int, ComponentInstance> _target;

    private Transform transform = new();

    /// <summary>
    /// Transform refers to the combination of fullscreen drag and zoom.
    /// Zoom is currently disabled.
    /// This function resets both.
    /// </summary>
    public void ResetTransform()
    {
        transform = new Transform();
    }

    private (double x, double y) zoomOrigin = (950 / 2, 1080 / 2); //assumes 1920x1080, doesn't really matter, but shouldn't change

    //compatibility property to reference into the transform without refactoring everything
    public double zoomFactor
    {
        get { return transform.scale; }
        set { transform.scale = value; }
    }

    /// <summary>
    /// Gets 1 of 4 coordinates of a connection line.
    /// </summary>
    /// <param name="conn">Connection to display.</param>
    /// <param name="stepSize"></param>
    /// <param name="offset"></param>
    /// <returns>The requested coordinate.</returns>
    private List<(double x1, double y1, double x2, double y2)> GetGridLines(InstanceConnection conn, double stepSize, double offset)
    {
        ElementPin[] toPins = conn.To.Data.pinInfo;
        ElementPin[] fromPins = conn.From.Data.pinInfo;
        var toPin = toPins[conn.ToId];
        var fromPin = fromPins[conn.FromId];
        var start = ZoomCoord((conn.From.X + fromPin.x, conn.From.Y + fromPin.y));
        var end = ZoomCoord((conn.To.X + toPin.x, conn.To.Y + toPin.y));

        var lines = new List<(double x1, double y1, double x2, double y2)>();

        double currentX = start.x;
        double currentY = start.y;

        // 1. Diagonal Start Segment
        double diagonalX = end.x > start.x ? currentX + stepSize + offset : currentX - stepSize - offset;
        double diagonalY = end.y > start.y ? currentY + stepSize + offset : currentY - stepSize - offset;
        lines.Add((currentX, currentY, diagonalX, diagonalY));
        currentX = diagonalX;
        currentY = diagonalY;

        // 2. Grid Path (align with target X, then target Y)
        while (Math.Abs(currentX - end.x) > stepSize)
        {
            double nextX = currentX + Math.Sign(end.x - currentX) * stepSize;
            lines.Add((currentX, currentY, nextX, currentY));
            currentX = nextX;
        }

        while (Math.Abs(currentY - end.y) > stepSize)
        {
            double nextY = currentY + Math.Sign(end.y - currentY) * stepSize;
            lines.Add((currentX, currentY, currentX, nextY));
            currentY = nextY;
        }

        // 3. Diagonal End Segment
        lines.Add((currentX, currentY, end.x, end.y));
        return lines;
    }


    /// <summary>
    /// Currently unused. Handles scrollwheel zooming.
    /// </summary>
    /// <param name="e">Provided scrollwheel event.</param>
    private void UpdZoom(WheelEventArgs e)
    {
        zoomFactor += e.DeltaY / -1000;

        zoomFactor = Math.Clamp(zoomFactor, .4, 3);


        foreach (var comp in comps.Values)
        {
            AdjustCompToZoom(comp);
        }
    }

    /// <summary>
    /// Attempts to scale a component in place to account for zoom.
    /// </summary>
    /// <param name="comp">Component to adjust.</param>
    /// <returns>the component, now adjusted.</returns>
    private ComponentInstance AdjustCompToZoom(ComponentInstance comp)
    {
        var coord = (x: comp.X, y: comp.Y);

        var z = ZoomCoord(coord);

        comp.zoomedX = z.x;
        comp.zoomedY = z.y;

        return comp;
    }

    /// <summary>
    /// Atteampts to calculate the total effect of zoom on a coordinate.
    /// </summary>
    /// <param name="coord">a coordinate to zoom</param>
    /// <returns>the zoomed coordinate.</returns>
    private (double x, double y) ZoomCoord((double x, double y) coord)
    {
        coord.x = (coord.x + (transform.translate.x * (1 / zoomFactor)) - zoomOrigin.x) * zoomFactor + zoomOrigin.x;
        coord.y = (coord.y + (transform.translate.y * (1 / zoomFactor)) - zoomOrigin.y) * zoomFactor + zoomOrigin.y;

        return coord;
    }

    /// <summary>
    /// Attempts to reverse the effects of zoom on a zoomed component.
    /// </summary>
    /// <param name="comp">the component in question.</param>
    /// <returns>the component, now returned to normal.</returns>
    public ComponentInstance UnZoom(ComponentInstance comp)
    {
        comp.X = (comp.X - zoomOrigin.x) / zoomFactor + zoomOrigin.x - (transform.translate.x * (1 / zoomFactor));
        comp.Y = (comp.Y - zoomOrigin.y) / zoomFactor + zoomOrigin.y - (transform.translate.y * (1 / zoomFactor));


        return comp;
    }


    //handle the start of drags that target a specific component
    private void DragComponentStart(MouseEventArgs e, KeyValuePair<int, ComponentInstance> target)
    {
        if (e.Button != 0) return;
        _dragging = true; //start drag, signal that there is a selected component, and remember it
        _hasTarget = true;
        this._target = target;
    }

    //generic continuous drag, whether or not there is a component.
    private void DragMiddle(MouseEventArgs e)
    {
        switch (_dragging)
        {
            //dragging a specific component, the target
            case true when _hasTarget:
                _target.Value.X += (e.MovementX / zoomFactor);
                _target.Value.Y += (e.MovementY / zoomFactor);
                AdjustCompToZoom(_target.Value);
                break;
            //dragging the canvas, all components
            case true:
            {
                transform.translate.x += e.MovementX;
                transform.translate.y += e.MovementY;
                foreach (var t in comps)
                {
                    //t.Value.x += (e.MovementX / zoomFactor);
                    //t.Value.y += (e.MovementY / zoomFactor);
                    AdjustCompToZoom(t.Value);
                }

                break;
            }
        }
    }

    bool dragEndFlag = false; //disable deselection at end of drag

    //handles the end of a drag targeting a specific component, removing the target
    private void DragComponentEnd(MouseEventArgs e)
    {
        _dragging = false;
        _hasTarget = false;
        dragEndFlag = true;
    }

    //canvas drag start, signal that there is a drag.
    private void DragStart(MouseEventArgs e)
    {
        if (e.Button == 0)
        {
            _dragging = true;
        }
    }

    //canvas drag end, stop drag
    private void DragEnd(MouseEventArgs e)
    {
        _dragging = false;
    }

    bool targetFound = false;

    //click on a component handler. 
    public void ComponentSelection(MouseEventArgs e, KeyValuePair<int, ComponentInstance> c)
    {
        targetFound = true;
        if (Pages.Index.App!.SelectedComponent < 0) //no previous selection
        {
            Pages.Index.App.SelectedComponent = c.Key;
        }
        else if (Pages.Index.App.SelectedComponent != c.Key) //selection is not the previously selected component. Could be || with prev, readability.
        {
            Pages.Index.App.SelectedComponent = c.Key;
        }
        else if (dragEndFlag) //avoid deselects at the end of drags
        {
            dragEndFlag = false;
            Pages.Index.App.SelectedComponent = c.Key;
        }
        else //catch weird stuff with deselect
        {
            Pages.Index.App.SelectedComponent = -1;
        }
    }

    //click on the canvas handler.
    private void CanvasClick()
    {
        if (!targetFound)
        {
            Pages.Index.App!.SelectedComponent = -2;
        }

        targetFound = false;
    }

	public void TriggerRefresh()
    {
        StateHasChanged();
        foreach (var comp in comps.Values)
        {
            AdjustCompToZoom(comp);  // Apply transform/zoom to each component
        }
        ConnLines.Clear();  // Remove all wires
        foreach (var comp in comps.Values)
        {
            foreach (var connMap in comp.ConnMap)
            {
                foreach (var conn in connMap.Value)
                {
                    ConnLines.Add(conn);  // Rebuild wires with correct positions
                }
            }
        }
    }

}