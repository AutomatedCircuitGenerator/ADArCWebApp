using System.CodeDom;
using ADArCWebApp.Shared;
using ADArCWebApp.Shared.Components;

namespace ADArCWebApp.ComponentNamespace
{

	/// <summary>
	/// Primary data repository. Figure out a way to do this dynamically or something later.
	/// 
	/// TODO: figure out how to improve this.
	/// </summary>
	public static class ComponentDeclarations
	{
		public static Dictionary<int, ComponentData> components = new()
		{
			{ 1, new ComponentDataBuilder("Uno Rev3", false, "Arduino", 0.33, 280, 210, typeof(RazorArduinoUno), codeForGen:new(){{"include", ""},{"global", ""}, {"setup", ""}, {"loopMain", ""},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","d10","d11","d12","d13","d14","d15","d16","d17","d18","d19","gnd", "5V", "3V3"], gsNodeName: "arduinouno_rev3").Finish() },
			{ 2, new ComponentDataBuilder("MEGA 2560", false, "Arduino", 0.3, 390, 195, typeof(RazorArduinoMega)).Finish() },
			{ 3, new ComponentDataBuilder("Uno WIFI Rev2", false, "Arduino", 1, 75, 75, pins: ["d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "d10", "d11", "d12", "d13", "d14", "d15", "d16", "d17", "d18", "d19", "d20", "d21", "gnd", "5V", "3.3V", "Vin", "reset"], gsNodeName: "arduinouno_wifi_rev2").Finish() },
			{ 4, new ComponentDataBuilder("Tactile push button", false, "Input/Buttons and Switches", 1, 75, 75, codeForGen: new() { { "include", ""},{"global", "const int buttonPin = ~\"2.1\";  // the number of the pushbutton pin\nint buttonState = 0;  // variable for reading the pushbutton status"}, {"setup", "// initialize the pushbutton pin as an input:\n  pinMode(buttonPin, INPUT);"}, {"loopMain", "// read the state of the pushbutton value:\n  buttonState = digitalRead(buttonPin);\n\n  // check if the pushbutton is pressed. If it is, the buttonState is HIGH:\n  if (buttonState == HIGH) {\n    Serial.println(\"button pushed\");\n  } "},{"functions", "" }, { "delayLoop", ""}, {"delayTime", "" } }, pins: ["2.1", "2.r", "1.1", "1.r"], gsNodeName: "pushbutton").Finish() },// i think this is the wrong rule
			{ 5, new ComponentDataBuilder("Switch", false, "Input/Buttons and Switches", 1, 75, 75).Finish() },
			{ 6, new ComponentDataBuilder("ADXL345", false, "Input/Acceleration Sensors", 1, 75, 75, codeForGen: new(){{"include", "#include <Wire.h>\n#include <Adafruit_Sensor.h>\n#include <Adafruit_ADXL345.h>"},{"global", "/* Assign a unique ID to this sensor at the same time */\nAdafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345);"}, {"setup", "#ifndef ESP8266\n  while (!Serial); // for Leonardo/Micro/Zero\n#endif\n  Serial.println(\"Accelerometer Test\"); Serial.println(\"\");\n  \n  /* Initialise the sensor */\n  if(!accel.begin())\n  {\n    /* There was a problem detecting the ADXL345 ... check your connections */\n    Serial.println(\"Ooops, no ADXL345 detected ... Check your wiring!\");\n    while(1);\n  }\n\n  /* Set the range to whatever is appropriate for your project */\n  accel.setRange(ADXL345_RANGE_16_G);\n  // accel.setRange(ADXL345_RANGE_8_G);\n  // accel.setRange(ADXL345_RANGE_4_G);\n  // accel.setRange(ADXL345_RANGE_2_G);\n  \n  /* Display some basic information on this sensor */\n  displaySensorDetails();\n  \n  /* Display additional settings (outside the scope of sensor_t) */\n  displayDataRate();\n  displayRange();\n  Serial.println(\"\");"}, {"loopMain", "/* Get a new sensor event */ \n  sensors_event_t event; \n  accel.getEvent(&event);\n \n  /* Display the results (acceleration is measured in m/s^2) */\n  Serial.print(\"X: \"); Serial.print(event.acceleration.x); Serial.print(\"  \");\n  Serial.print(\"Y: \"); Serial.print(event.acceleration.y); Serial.print(\"  \");\n  Serial.print(\"Z: \"); Serial.print(event.acceleration.z); Serial.print(\"  \");Serial.println(\"m/s^2 \");\n  delay(500);"},{"functions", "void displaySensorDetails(void)\n{\n  sensor_t sensor;\n  accel.getSensor(&sensor);\n  Serial.println(\"------------------------------------\");\n  Serial.print  (\"Sensor:       \"); Serial.println(sensor.name);\n  Serial.print  (\"Driver Ver:   \"); Serial.println(sensor.version);\n  Serial.print  (\"Unique ID:    \"); Serial.println(sensor.sensor_id);\n  Serial.print  (\"Max Value:    \"); Serial.print(sensor.max_value); Serial.println(\" m/s^2\");\n  Serial.print  (\"Min Value:    \"); Serial.print(sensor.min_value); Serial.println(\" m/s^2\");\n  Serial.print  (\"Resolution:   \"); Serial.print(sensor.resolution); Serial.println(\" m/s^2\");  \n  Serial.println(\"------------------------------------\");\n  Serial.println(\"\");\n  delay(500);\n}\nvoid displayDataRate(void)\n{\n  Serial.print  (\"Data Rate:    \"); \n  \n  switch(accel.getDataRate())\n  {\n    case ADXL345_DATARATE_3200_HZ:\n      Serial.print  (\"3200 \"); \n      break;\n    case ADXL345_DATARATE_1600_HZ:\n      Serial.print  (\"1600 \"); \n      break;\n    case ADXL345_DATARATE_800_HZ:\n      Serial.print  (\"800 \"); \n      break;\n    case ADXL345_DATARATE_400_HZ:\n      Serial.print  (\"400 \"); \n      break;\n    case ADXL345_DATARATE_200_HZ:\n      Serial.print  (\"200 \"); \n      break;\n    case ADXL345_DATARATE_100_HZ:\n      Serial.print  (\"100 \"); \n      break;\n    case ADXL345_DATARATE_50_HZ:\n      Serial.print  (\"50 \"); \n      break;\n    case ADXL345_DATARATE_25_HZ:\n      Serial.print  (\"25 \"); \n      break;\n    case ADXL345_DATARATE_12_5_HZ:\n      Serial.print  (\"12.5 \"); \n      break;\n    case ADXL345_DATARATE_6_25HZ:\n      Serial.print  (\"6.25 \"); \n      break;\n    case ADXL345_DATARATE_3_13_HZ:\n      Serial.print  (\"3.13 \"); \n      break;\n    case ADXL345_DATARATE_1_56_HZ:\n      Serial.print  (\"1.56 \"); \n      break;\n    case ADXL345_DATARATE_0_78_HZ:\n      Serial.print  (\"0.78 \"); \n      break;\n    case ADXL345_DATARATE_0_39_HZ:\n      Serial.print  (\"0.39 \"); \n      break;\n    case ADXL345_DATARATE_0_20_HZ:\n      Serial.print  (\"0.20 \"); \n      break;\n    case ADXL345_DATARATE_0_10_HZ:\n      Serial.print  (\"0.10 \"); \n      break;\n    default:\n      Serial.print  (\"???? \"); \n      break;\n  }  \n  Serial.println(\" Hz\");  \n}\nvoid displayRange(void)\n{\n  Serial.print  (\"Range:         +/- \"); \n\n  switch (accel.getRange())\n  {\n    case ADXL345_RANGE_16_G:\n Serial.print(\"16 \"); \n      break;\n    case ADXL345_RANGE_8_G:\n Serial.print(\"8 \"); \n      break;\n    case ADXL345_RANGE_4_G:\n Serial.print(\"4 \"); \n      break;\n    case ADXL345_RANGE_2_G:\n Serial.print(\"2 \"); \n      break;\n    default:\n Serial.print(\" ?? \"); \n      break;\n  }  \n Serial.println(\" g\");  \n}\n"}, { "delayLoop", ""}, {"delayTime", ""}}, pins: ["pin1","pin2","pin3","pin4","pin5","pin6","pin7","pin8","pin9"], gsNodeName: "adxl345").Finish() },
			{ 7, new ComponentDataBuilder("MPU6050", true, "Input/Acceleration Sensors", 1.3, 85, 65, typeof(RazorMPU6050), codeForGen: new(){{"include", "#include <Adafruit_MPU6050.h>\n#include <Adafruit_Sensor.h>\n#include <Wire.h>"},{"global", "Adafruit_MPU6050 mpu;"}, {"setup", "  while (!Serial)\n    delay(10); // will pause Zero, Leonardo, etc until serial console opens\n\n  Serial.println(\"Adafruit MPU6050 test!\");\n\n  // Try to initialize!\n  if (!mpu.begin()) {\n    Serial.println(\"Failed to find MPU6050 chip\");\n    while (1) {\n      delay(10);\n    }\n  }\n  Serial.println(\"MPU6050 Found!\");\n\n  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);\n  Serial.print(\"Accelerometer range set to: \");\n  switch (mpu.getAccelerometerRange()) {\n  case MPU6050_RANGE_2_G:\n    Serial.println(\"+-2G\");\n    break;\n  case MPU6050_RANGE_4_G:\n    Serial.println(\"+-4G\");\n    break;\n  case MPU6050_RANGE_8_G:\n    Serial.println(\"+-8G\");\n    break;\n  case MPU6050_RANGE_16_G:\n    Serial.println(\"+-16G\");\n    break;\n  }\n  mpu.setGyroRange(MPU6050_RANGE_500_DEG);\n  Serial.print(\"Gyro range set to: \");\n  switch (mpu.getGyroRange()) {\n  case MPU6050_RANGE_250_DEG:\n    Serial.println(\"+- 250 deg/s\");\n    break;\n  case MPU6050_RANGE_500_DEG:\n    Serial.println(\"+- 500 deg/s\");\n    break;\n  case MPU6050_RANGE_1000_DEG:\n    Serial.println(\"+- 1000 deg/s\");\n    break;\n  case MPU6050_RANGE_2000_DEG:\n    Serial.println(\"+- 2000 deg/s\");\n    break;\n  }\n\n  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);\n  Serial.print(\"Filter bandwidth set to: \");\n  switch (mpu.getFilterBandwidth()) {\n  case MPU6050_BAND_260_HZ:\n    Serial.println(\"260 Hz\");\n    break;\n  case MPU6050_BAND_184_HZ:\n    Serial.println(\"184 Hz\");\n    break;\n  case MPU6050_BAND_94_HZ:\n    Serial.println(\"94 Hz\");\n    break;\n  case MPU6050_BAND_44_HZ:\n    Serial.println(\"44 Hz\");\n    break;\n  case MPU6050_BAND_21_HZ:\n    Serial.println(\"21 Hz\");\n    break;\n  case MPU6050_BAND_10_HZ:\n    Serial.println(\"10 Hz\");\n    break;\n  case MPU6050_BAND_5_HZ:\n    Serial.println(\"5 Hz\");\n    break;\n  }\n\n  Serial.println(\"\");\n  delay(100);"}, {"loopMain", "/* Get new sensor events with the readings */\n  sensors_event_t a, g, temp;\n  mpu.getEvent(&a, &g, &temp);\n\n  /* Print out the values */\n  Serial.print(\"Acceleration X: \");\n  Serial.print(a.acceleration.x);\n  Serial.print(\", Y: \");\n  Serial.print(a.acceleration.y);\n  Serial.print(\", Z: \");\n  Serial.print(a.acceleration.z);\n  Serial.println(\" m/s^2\");\n\n  Serial.print(\"Rotation X: \");\n  Serial.print(g.gyro.x);\n  Serial.print(\", Y: \");\n  Serial.print(g.gyro.y);\n  Serial.print(\", Z: \");\n  Serial.print(g.gyro.z);\n  Serial.println(\" rad/s\");\n\n  Serial.print(\"Temperature: \");\n  Serial.print(temp.temperature);\n  Serial.println(\" degC\");\n\n  Serial.println(\"\");\n  delay(500);"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4","pin5","pin6","pin7","pin8"], gsNodeName: "mpu6050").Finish() },
			{ 8, new ComponentDataBuilder("BNO-055", true, "Input/Acceleration Sensors", 1, 120, 90, typeof(RazorBNO055), codeForGen:new(){{"include", "#include <Wire.h>\n#include <Adafruit_Sensor.h>\n#include <Adafruit_BNO055.h>\n#include <utility/imumaths.h>"},{"global", "/* Set the delay between fresh samples */\n#define BNO055_SAMPLERATE_DELAY_MS (100)\n\n// Check I2C device address and correct line below (by default address is 0x29 or 0x28)\n//                                   id, address\nAdafruit_BNO055 bno = Adafruit_BNO055(-1, 0x28, &wire);"}, {"setup", "  while (!Serial) delay(10);  // wait for serial port to open!\n\n  Serial.println(\"Orientation Sensor Raw Data Test\"); Serial.println(\"\");\n\n  /* Initialise the sensor */\n  if(!bno.begin())\n  {\n    /* There was a problem detecting the BNO055 ... check your connections */\n    Serial.print(\"Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!\");\n    while(1);\n  }\n\n  delay(1000);\n\n  /* Display the current temperature */\n  int8_t temp = bno.getTemp();\n  Serial.print(\"Current Temperature: \");\n  Serial.print(temp);\n  Serial.println(\" C\");\n  Serial.println(\"\");\n\n  bno.setExtCrystalUse(true);\n\n  Serial.println(\"Calibration status values: 0=uncalibrated, 3=fully calibrated\");"}, {"loopMain", "  // Possible vector values can be:\n  // - VECTOR_ACCELEROMETER - m/s^2\n  // - VECTOR_MAGNETOMETER  - uT\n  // - VECTOR_GYROSCOPE     - rad/s\n  // - VECTOR_EULER         - degrees\n  // - VECTOR_LINEARACCEL   - m/s^2\n  // - VECTOR_GRAVITY       - m/s^2\n  imu::Vector<3> euler = bno.getVector(Adafruit_BNO055::VECTOR_EULER);\n\n  /* Display the floating point data */\n  Serial.print(\"X: \");\n  Serial.print(euler.x());\n  Serial.print(\" Y: \");\n  Serial.print(euler.y());\n  Serial.print(\" Z: \");\n  Serial.print(euler.z());\n  Serial.print(\"\t\t\");\n\n  /*\n  // Quaternion data\n  imu::Quaternion quat = bno.getQuat();\n  Serial.print(\"qW: \");\n  Serial.print(quat.w(), 4);\n  Serial.print(\" qX: \");\n  Serial.print(quat.x(), 4);\n  Serial.print(\" qY: \");\n  Serial.print(quat.y(), 4);\n  Serial.print(\" qZ: \");\n  Serial.print(quat.z(), 4);\n  Serial.print(\"\t\t\");\n  */\n\n  /* Display calibration status for each sensor. */\n  uint8_t system, gyro, accel, mag = 0;\n  bno.getCalibration(&system, &gyro, &accel, &mag);\n  Serial.print(\"CALIBRATION: Sys=\");\n  Serial.print(system, DEC);\n  Serial.print(\" Gyro=\");\n  Serial.print(gyro, DEC);\n  Serial.print(\" Accel=\");\n  Serial.print(accel, DEC);\n  Serial.print(\" Mag=\");\n  Serial.println(mag, DEC);\n\n  delay(BNO055_SAMPLERATE_DELAY_MS);"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["int","adr","5V","gnd","rst","sda","scl","ps0","ps1"], listenOn:["sda","scl"], gsNodeName: "bno055").Property("x", 0).Property("y", 0).Property("z", 0).Finish() },
			{ 9, new ComponentDataBuilder("TF-Luna Lidar - I2C", false, "Input/Distance Sensors", 1, 75, 75, codeForGen:new(){{"include", "#include <Arduino.h>\n#include <Wire.h>\n#include <TFLI2C.h>                // TFLuna-I2C Library v.0.2.0"},{"global", "TFLI2C tflI2C;\n\n// Use these defaults or insert your own values\nint16_t  tfAddr = TFL_DEF_ADR;    // default I2C address\nuint16_t tfFrame = TFL_DEF_FPS;   // default frame rate\n\n// device variables passed back by getData\nint16_t  tfDist = 0 ;   // distance in centimeters\nint16_t  tfFlux = 0 ;   // signal quality in arbitrary units\nint16_t  tfTemp = 0 ;   // temperature in 0.01 degree Celsius\n\n// other device variables\nuint16_t tfTime = 0;    // device clock in milliseconds\nuint8_t  tfVer[3];      // device version number\nuint8_t  tfCode[14];    // device serial number\n\n// sub-loop counter for Time display\nuint8_t tfCount = 0;"}, {"setup", "  Wire.begin();           // Initialize Wire library\n\n    Serial.println( \"TFLI2C example code\"); // say \"Hello!\"\n    Serial.println( \"4 NOV 2021\");          // and add date\n\n    // Execute a group of commands.\n    // Comment this out if not needed.\n    sampleCommands( tfAddr);"}, {"loopMain", "  // If data is read without error...\n    if( tflI2C.getData( tfDist, tfFlux, tfTemp, tfAddr))\n    {\n        Serial.print(\"Dist: \");      // ...print distance,\n        Serial.print(tfDist);\n        Serial.print(\" | Flux: \");   // ...print quality\n        Serial.print(tfFlux);\n\n        // Convert temperature from hundredths\n        // of a degree to a whole number and...\n        tfTemp = int16_t( tfTemp / 100);\n\n        Serial.print(\" | Temp: \");     // ...print temperature.\n        Serial.println( tfTemp);\n    }\n    else tflI2C.printStatus();        // else, print error status.\n\n    // Every ten loops, print device time\n    // in milliseconds and reset the counter.\n    if( tfCount < 10) ++tfCount;\n    else\n    {\n        Serial.print( \"Get Time: \");\n        tflI2C.Get_Time( tfTime, tfAddr);\n        Serial.println(  tfTime);\n        tfCount = 0;\n    }\n\n    delay( 50);"},{"functions", "//  This is a group of various sample\n//  commands that can be called at setup.\nvoid sampleCommands( uint8_t adr)\n{\n    Serial.print( \"Device Address: \");\n    Serial.println( adr);\n\n    Serial.print(\"System Reset: \");\n    if( tflI2C.Soft_Reset( adr))\n    {\n        Serial.println( \"Passed\");\n    }\n    else tflI2C.printStatus();  // `printStatus()` is for troubleshooting,\n                                //  It's not necessary for operation.\n    delay(500);\n\n    Serial.print( \"Get Firmware Version: \");\n    if( tflI2C.Get_Firmware_Version( tfVer, adr))\n    {\n      Serial.print( tfVer[2]);\n      Serial.print( \".\");\n      Serial.print( tfVer[1]);\n      Serial.print( \".\");\n      Serial.println( tfVer[0]);\n    }\n    else tflI2C.printStatus();    \n    delay(500);\n\n    Serial.print( \"Get Serial Number: \");\n    if( tflI2C.Get_Prod_Code( tfCode, adr))\n    {\n      for( uint8_t i = 0; i < 14; ++i)\n      {\n        Serial.print( char( tfCode[i]));\n      }\n      Serial.println();\n    }\n    else tflI2C.printStatus();\n    delay(500);\n\n    // In main 'loop', command to print\n    // device time in milliseconds is\n    // called every 10 loops.\n    Serial.print( \"Get Time: \");\n    if( tflI2C.Get_Time( tfTime, adr))\n    {\n      Serial.println(  tfTime);\n    }\n    else tflI2C.printStatus();\n    delay(500);\n\n    Serial.print( \"Set Frame Rate to: \");\n    if( tflI2C.Set_Frame_Rate( tfFrame, adr))\n    {\n      Serial.println(  tfFrame);\n    }\n    else tflI2C.printStatus();\n    delay(500);\n    \n    //  Read frame rate back from the device\n    Serial.print( \"Get Frame Rate: \");\n    if( tflI2C.Get_Frame_Rate( tfFrame, adr))\n    {\n      Serial.println(  tfFrame);\n    }\n    else tflI2C.printStatus();\n    delay(500);\n\n}"}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4"], gsNodeName: "lidar_tfluna_I2C").Finish() },
			{ 10, new ComponentDataBuilder("TF-Luna Lidar - UART", false, "Input/Distance Sensors", 1, 75, 75).Finish() },
			{ 11, new ComponentDataBuilder("RPLIDAR-A1 Lidar", false, "Input/Distance Sensors", 1, 75, 75, paneHoverText: "Distance sensor", codeForGen:new(){{"include", "#include <RPLidar.h>"},{"global", "RPLidar lidar;  // Create an driver instance\n#define RPLIDAR_MOTOR ~\"pin6\" // The PWM pin for control the speed of RPLIDAR's motor.\nfloat minDistance = 100000;\nfloat angleAtMinDist = 0;"}, {"setup", "  lidar.begin(Serial1);// bind the RPLIDAR driver to the arduino hardware Serial No1 (TX1, RX1) on Mega\n\n  // set pin modes\n  pinMode(RPLIDAR_MOTOR, OUTPUT);"}, {"loopMain", "  //Lidar==============================\n  analogWrite(RPLIDAR_MOTOR, 255);\n  if (IS_OK(lidar.waitPoint())) {\n    //perform data processing here...\n    float distance = lidar.getCurrentPoint().distance;\n    float angle = lidar.getCurrentPoint().angle;\n\n    if (lidar.getCurrentPoint().startBit) {\n      // a new scan, display the previous data...\n      displayColor(angleAtMinDist, minDistance);\n      minDistance = 100000;\n      angleAtMinDist = 0;\n    } else {\n      if ( distance > 0 &&  distance < minDistance) {\n        minDistance = distance;\n        angleAtMinDist = angle;\n      }\n    }\n  } else {\n    analogWrite(RPLIDAR_MOTOR, 0); //stop the rplidar motor\n\n    // try to detect RPLIDAR...\n    rplidar_response_device_info_t info;\n    if (IS_OK(lidar.getDeviceInfo(info, 100))) {\n      //detected...\n      lidar.startScan();\n      analogWrite(RPLIDAR_MOTOR, 255);\n      delay(1000);\n    }\n  }"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4","pin5","pin6","pin7"], gsNodeName: "rplidar").Finish() },
			{ 12, new ComponentDataBuilder("Ultrasonic", true, "Input/Distance Sensors", 0.65, 170, 95, typeof(RazorHCSR04), paneHoverText: "HC-SR04", codeForGen:new(){{"include", ""},{"global", "const int trigPin = ~\"pin2\";\nconst int echoPin = ~\"pin3\";\n\nfloat duration, distance;"}, {"setup", "  pinMode(trigPin, OUTPUT);\n  pinMode(echoPin, INPUT);"}, {"loopMain", "  digitalWrite(trigPin, LOW);\n  delayMicroseconds(2);\n  digitalWrite(trigPin, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(trigPin, LOW);\n  duration = pulseIn(echoPin, HIGH);\n  distance = (duration * .0343) / 2;\n  Serial.print(\"Distance: \");\n  Serial.println(distance);\n  delay(100);"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4"], listenOn:["pin2","pin3"], gsNodeName: "hcsr04").Property("distance", 20.0).Finish() },
			{ 13, new ComponentDataBuilder("IR Distance", false, "Input/Distance Sensors", 1, 75, 75, paneHoverText: "GP2Y0A21YK0F").Finish() },
			{ 14, new ComponentDataBuilder("MQ-3", true, "Input/Gas Sensors", .66, 75, 75, typeof(RazorMQ_3), codeForGen:new(){{"include", ""},{"global", "/* Replace these values with your own readings */\n#define Sober 120   // Define max value that we consider sober\n#define Drunk 400   // Define min value that we consider drunk\n#define MQ3pin ~\"pin4\"\nfloat sensorValue;  //variable to store sensor value"}, {"setup", "  Serial.println(\"MQ3 warming up!\");\n  delay(20000); // allow the MQ3 to warm up"}, {"loopMain", "  sensorValue = analogRead(MQ3pin); // read analog input pin 0\n\n  Serial.print(\"Sensor Value: \");\n  Serial.print(sensorValue);\n  \n  // Determine the status\n  if (sensorValue < Sober) {\n    Serial.println(\"  |  Status: Stone Cold Sober\");\n  } else if (sensorValue >= Sober && sensorValue < Drunk) {\n    Serial.println(\"  |  Status: Drinking but within legal limits\");\n  } else {\n    Serial.println(\"  |  Status: DRUNK\");\n  }\n  \n  delay(2000); // wait 2s for next reading\n"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4"], gsNodeName: "mq3").Property("translateOnInput", true).Property("alcohol",0.0).Finish() },
			{ 15, new ComponentDataBuilder("SGP41", false, "Input/Gas Sensors", 1, 75, 75).Finish() },
			{ 16, new ComponentDataBuilder("KY-018 LDR", false, "Input/Light Sensors", 1, 75, 75, codeForGen:new(){{"include", ""},{"global", "const int photoresistorPin = ~\"pin1\"; // Arduino analog input pin connected to KY-018 OUT pin (S)"}, {"setup", ""}, {"loopMain", "  int sensorValue = analogRead(photoresistorPin); // Read analog value from the photoresistor\n\n  // Map the analog value to a light intensity range (adjust the values based on your specific needs)\n  int lightLevel = map(sensorValue, 0, 1023, 0, 100);\n\n  Serial.print(\"Light Intensity: \");\n  Serial.print(lightLevel);\n  Serial.println(\"%\");\n\n  delay(1000); // Wait for a second"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3"], gsNodeName: "ky018").Finish() },
			{ 17, new ComponentDataBuilder("Ambient Light", false, "Input/Light Sensors", 1, 75, 75, paneHoverText: "BH1750").Finish() },
			{ 18, new ComponentDataBuilder("Luminosity", false, "Input/Light Sensors", 1, 75, 75, paneHoverText: "TSL2561").Finish() },
			{ 19, new ComponentDataBuilder("Alt - Ambient Light", false, "Input/Light Sensors", 1, 75, 75, paneHoverText: "TEMT6000").Finish() },
			{ 20, new ComponentDataBuilder("DHT11 / DHT22 ", true, "Input/Temperature and Humidity Sensors", 0.9, 60, 120, typeof(RazorDHT22), codeForGen:new(){{"include", "#include <DHT.h>"},{"global", "#define DHTPIN ~\"signal\"     // Digital pin connected to the DHT sensor\n// Feather HUZZAH ESP8266 note: use pins 3, 4, 5, 12, 13 or 14 --\n// Pin 15 can work but DHT must be disconnected during program upload.\n\n// Uncomment whatever type you're using!\n//#define DHTTYPE DHT11   // DHT 11\n#define DHTTYPE DHT22   // DHT 22  (AM2302), AM2321\n//#define DHTTYPE DHT21   // DHT 21 (AM2301)\n\n// Connect pin 1 (on the left) of the sensor to +5V\n// NOTE: If using a board with 3.3V logic like an Arduino Due connect pin 1\n// to 3.3V instead of 5V!\n// Connect pin 2 of the sensor to whatever your DHTPIN is\n// Connect pin 3 (on the right) of the sensor to GROUND (if your sensor has 3 pins)\n// Connect pin 4 (on the right) of the sensor to GROUND and leave the pin 3 EMPTY (if your sensor has 4 pins)\n// Connect a 10K resistor from pin 2 (data) to pin 1 (power) of the sensor\n\n// Initialize DHT sensor.\n// Note that older versions of this library took an optional third parameter to\n// tweak the timings for faster processors.  This parameter is no longer needed\n// as the current DHT reading algorithm adjusts itself to work on faster procs.\nDHT dht(DHTPIN, DHTTYPE);"}, {"setup", "Serial.println(F(\"DHTxx test!\"));\n\n  dht.begin();"}, {"loopMain", "// Wait a few seconds between measurements.\n  delay(2000);\n\n  // Reading temperature or humidity takes about 250 milliseconds!\n  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)\n  float h = dht.readHumidity();\n  // Read temperature as Celsius (the default)\n  float t = dht.readTemperature();\n  // Read temperature as Fahrenheit (isFahrenheit = true)\n  float f = dht.readTemperature(true);\n\n  // Check if any reads failed and exit early (to try again).\n  if (isnan(h) || isnan(t) || isnan(f)) {\n    Serial.println(F(\"Failed to read from DHT sensor!\"));\n    return;\n  }\n\n  // Compute heat index in Fahrenheit (the default)\n  float hif = dht.computeHeatIndex(f, h);\n  // Compute heat index in Celsius (isFahreheit = false)\n  float hic = dht.computeHeatIndex(t, h, false);\n\n  Serial.print(F(\"Humidity: \"));\n  Serial.print(h);\n  Serial.print(F(\"%  Temperature: \"));\n  Serial.print(t);\n  Serial.print(F(\"°C \"));\n  Serial.print(f);\n  Serial.print(F(\"°F  Heat index: \"));\n  Serial.print(hic);\n  Serial.print(F(\"°C \"));\n  Serial.print(hif);\n  Serial.println(F(\"°F\"));"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["Vcc","signal","gnd"], listenOn:["signal"], gsNodeName: "dht22").Property("humidity", 40.0).Property("temperature", 20.0).Finish() },
			{ 21, new ComponentDataBuilder("SHT31", false, "Input/Temperature and Humidity Sensors", 1, 75, 75).Finish() },
			{ 22, new ComponentDataBuilder("DS18B20", false, "Input/Temperature and Humidity Sensors", 1, 75, 75, codeForGen:new(){{"include", "#include <OneWire.h>"},{"global", "OneWire  ds(~\"pin2\"); "}, {"setup", ""}, {"loopMain", "  byte i;\n  byte present = 0;\n  byte type_s;\n  byte data[9];\n  byte addr[8];\n  float celsius, fahrenheit;\n  \n  if ( !ds.search(addr)) {\n    Serial.println(\"No more addresses.\");\n    Serial.println();\n    ds.reset_search();\n    delay(250);\n    return;\n  }\n  \n  Serial.print(\"ROM =\");\n  for( i = 0; i < 8; i++) {\n    Serial.write(' ');\n    Serial.print(addr[i], HEX);\n  }\n\n  if (OneWire::crc8(addr, 7) != addr[7]) {\n      Serial.println(\"CRC is not valid!\");\n      return;\n  }\n  Serial.println();\n \n  // the first ROM byte indicates which chip\n  switch (addr[0]) {\n    case 0x10:\n      Serial.println(\"  Chip = DS18S20\");  // or old DS1820\n      type_s = 1;\n      break;\n    case 0x28:\n      Serial.println(\"  Chip = DS18B20\");\n      type_s = 0;\n      break;\n    case 0x22:\n      Serial.println(\"  Chip = DS1822\");\n      type_s = 0;\n      break;\n    default:\n      Serial.println(\"Device is not a DS18x20 family device.\");\n      return;\n  } \n\n  ds.reset();\n  ds.select(addr);\n  ds.write(0x44, 1);        // start conversion, with parasite power on at the end\n  \n  delay(1000);     // maybe 750ms is enough, maybe not\n  // we might do a ds.depower() here, but the reset will take care of it.\n  \n  present = ds.reset();\n  ds.select(addr);    \n  ds.write(0xBE);         // Read Scratchpad\n\n  Serial.print(\"  Data = \");\n  Serial.print(present, HEX);\n  Serial.print(\" \");\n  for ( i = 0; i < 9; i++) {           // we need 9 bytes\n    data[i] = ds.read();\n    Serial.print(data[i], HEX);\n    Serial.print(\" \");\n  }\n  Serial.print(\" CRC=\");\n  Serial.print(OneWire::crc8(data, 8), HEX);\n  Serial.println();\n\n  // Convert the data to actual temperature\n  // because the result is a 16 bit signed integer, it should\n  // be stored to an \"int16_t\" type, which is always 16 bits\n  // even when compiled on a 32 bit processor.\n  int16_t raw = (data[1] << 8) | data[0];\n  if (type_s) {\n    raw = raw << 3; // 9 bit resolution default\n    if (data[7] == 0x10) {\n      // \"count remain\" gives full 12 bit resolution\n      raw = (raw & 0xFFF0) + 12 - data[6];\n    }\n  } else {\n    byte cfg = (data[4] & 0x60);\n    // at lower res, the low bits are undefined, so let's zero them\n    if (cfg == 0x00) raw = raw & ~7;  // 9 bit resolution, 93.75 ms\n    else if (cfg == 0x20) raw = raw & ~3; // 10 bit res, 187.5 ms\n    else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms\n    //// default is 12 bit resolution, 750 ms conversion time\n  }\n  celsius = (float)raw / 16.0;\n  fahrenheit = celsius * 1.8 + 32.0;\n  Serial.print(\"  Temperature = \");\n  Serial.print(celsius);\n  Serial.print(\" Celsius, \");\n  Serial.print(fahrenheit);\n  Serial.println(\" Fahrenheit\");"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3"], gsNodeName: "ds18b20").Finish() },
			{ 23, new ComponentDataBuilder("Hall effect", false, "Input/Other Sensors", 1, 75, 75, paneHoverText: "KY-024", codeForGen:new(){{"include", ""},{"global", "int digitalPin = ~\"pin1\"; // linear Hall magnetic sensor digital interface\nint analogPin = ~\"pin4\"; // linear Hall magnetic sensor analog interface\nint digitalVal ; // digital readings\nint analogVal; // analog readings"}, {"setup", "  pinMode (digitalPin, INPUT); \n  pinMode(analogPin, INPUT); "}, {"loopMain", "  // Read the digital interface\n  digitalVal = digitalRead(digitalPin) ;\n  Serial.print(\"ky024 digital value: \");\n  Serial.println(digitalVal); // print digital value\n  analogVal = analogRead(analogPin);\n  Serial.print(\"ky024 analog value: \");\n  Serial.println(analogVal); // print analog value"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4"], gsNodeName: "ky024").Finish() },
			{ 24, new ComponentDataBuilder("Hall effect", true, "Input/Other Sensors", 1.15, 60, 115, typeof(RazorKY003), paneHoverText: "KY-003", codeForGen:new(){{"include", ""},{"global", "int sensor = ~\"pin3\"; //sensor pin\nint val; //numeric variable"}, {"setup", "  pinMode(sensor, INPUT); //set sensor pin as input"}, {"loopMain", "  val = digitalRead(sensor); //Read the sensor\n  Serial.print(\"ky003 value: \");\n  Serial.println(val); "},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3"], gsNodeName: "ky003").Finish() },
			{ 25, new ComponentDataBuilder("Hall effect", false, "Input/Other Sensors", 1, 75, 75, paneHoverText: "KY-004").Finish() },
			{ 26, new ComponentDataBuilder("K-Thermocouple", true, "Input/Temperature and Humidity Sensors", .9, 100, 75,typeof(RazorMAX6675), paneHoverText: "MAX6675", codeForGen:new(){{"include", "#include <MAX6675.h>"},{"global", "#define CS_PIN ~\"cs\"\nMAX6675 tcouple(CS_PIN);"}, {"setup", "Serial.begin(9600);"}, {"loopMain", "float celsius = tcouple.readTempC();\n  float fahrenheit = tcouple.readTempF();\n  Serial.print(\"T in C = \");\n  Serial.print(celsius);\n  Serial.print(\". T in Fahrenheit = \");\n  Serial.println(fahrenheit);\n  delay(500);"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["5V","gnd","so","cs","sck"], gsNodeName: "max6675").Property("temperature", 20.0).Finish() },
			{ 27, new ComponentDataBuilder("PIR motion sensor", true, "Input/Other Sensors", 1, 75, 75,typeof(RazorHCSR501), paneHoverText: "HC-SR501", codeForGen:new(){{"include", ""},{"global", "int inputPin = ~\"pin2\"; // choose the input pin (for PIR sensor)\nint pirState = LOW; // we start, assuming no motion detected\nint val = 0; // variable for reading the pin status"}, {"setup", "  pinMode(inputPin, INPUT); // declare sensor as input"}, {"loopMain", "  val = digitalRead(inputPin); // read input value\n  if (val == HIGH) { // check if the input is HIGH\n    if (pirState == LOW) {\n      // we have just turned on\n      Serial.println(\"Motion detected!\");\n      // We only want to print on the output change, not state\n      pirState = HIGH;\n    }\n  } else {\n    if (pirState == HIGH) {\n      // we have just turned of\n      Serial.println(\"Motion ended!\");\n      // We only want to print on the output change, not state\n      pirState = LOW;\n    }\n  }"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3"], gsNodeName: "hcsr501").Finish() },
			{ 28, new ComponentDataBuilder("IR receiver", true, "Input/Other Sensors", 1.3, 65, 90, typeof(RazorKY022), paneHoverText: "KY-022", codeForGen:new(){{"include", "#include <IRremote.h>"},{"global", "int IRPIN = ~\"pin3\";"}, {"setup", "  Serial.println(\"Enabling IRin\");\n\n  IrReceiver.begin(IRPIN, ENABLE_LED_FEEDBACK);\n  Serial.println(\"Enabled IRin\");"}, {"loopMain", "  if (IrReceiver.decode())\n\n  {\n\n    Serial.println(IrReceiver.decodedIRData.decodedRawData, HEX);\n\n    IrReceiver.resume();\n  }\n\n  delay(500);"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3"], gsNodeName: "ky022").Finish() },
			{ 29, new ComponentDataBuilder("SD Card Reader", false, "Input/Other Sensors", 1, 75, 75, codeForGen:new(){{"include", "#include <SPI.h>\n#include <SD.h>"},{"global", "Sd2Card card;\nSdVolume volume;\nSdFile root;\nconst int chipSelect = ~\"pin6\";"}, {"setup", "  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n\n  Serial.print(\"\nInitializing SD card...\");\n\n  // we'll use the initialization code from the utility libraries\n  // since we're just testing if the card is working!\n  if (!card.init(SPI_HALF_SPEED, chipSelect)) {\n    Serial.println(\"initialization failed. Things to check:\");\n    Serial.println(\"* is a card inserted?\");\n    Serial.println(\"* is your wiring correct?\");\n    Serial.println(\"* did you change the chipSelect pin to match your shield or module?\");\n    while (1);\n  } else {\n    Serial.println(\"Wiring is correct and a card is present.\");\n  }\n\n  // print the type of card\n  Serial.println();\n  Serial.print(\"Card type:         \");\n  switch (card.type()) {\n    case SD_CARD_TYPE_SD1:\n      Serial.println(\"SD1\");\n      break;\n    case SD_CARD_TYPE_SD2:\n      Serial.println(\"SD2\");\n      break;\n    case SD_CARD_TYPE_SDHC:\n      Serial.println(\"SDHC\");\n      break;\n    default:\n      Serial.println(\"Unknown\");\n  }\n\n  // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32\n  if (!volume.init(card)) {\n    Serial.println(\"Could not find FAT16/FAT32 partition.\nMake sure you've formatted the card\");\n    while (1);\n  }\n\n  Serial.print(\"Clusters:          \");\n  Serial.println(volume.clusterCount());\n  Serial.print(\"Blocks x Cluster:  \");\n  Serial.println(volume.blocksPerCluster());\n\n  Serial.print(\"Total Blocks:      \");\n  Serial.println(volume.blocksPerCluster() * volume.clusterCount());\n  Serial.println();\n\n  // print the type and size of the first FAT-type volume\n  uint32_t volumesize;\n  Serial.print(\"Volume type is:    FAT\");\n  Serial.println(volume.fatType(), DEC);\n\n  volumesize = volume.blocksPerCluster();    // clusters are collections of blocks\n  volumesize *= volume.clusterCount();       // we'll have a lot of clusters\n  volumesize /= 2;                           // SD card blocks are always 512 bytes (2 blocks are 1KB)\n  Serial.print(\"Volume size (Kb):  \");\n  Serial.println(volumesize);\n  Serial.print(\"Volume size (Mb):  \");\n  volumesize /= 1024;\n  Serial.println(volumesize);\n  Serial.print(\"Volume size (Gb):  \");\n  Serial.println((float)volumesize / 1024.0);\n\n  Serial.println(\"\nFiles found on the card (name, date and size in bytes): \");\n  root.openRoot(volume);\n\n  // list all files in the card with date and size\n  root.ls(LS_R | LS_DATE | LS_SIZE);"}, {"loopMain", ""},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4","pin5","pin6"], gsNodeName: "sdCard").Finish() },
			{ 30, new ComponentDataBuilder("Load Cell(HX711)", true, "Input/Other Sensors", .6, 200, 100, typeof(RazorHX711), paneHoverText: "TAL221", codeForGen:new(){{"include", "#include <HX711.h>"},{"global", "const int LOADCELL_DOUT_PIN = ~\"dat\";\nconst int LOADCELL_SCK_PIN = ~\"clk\";\nHX711 scale; "}, { "setup", "  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN); "}, { "loopMain", "  if (scale.is_ready()) {\n    long reading = scale.read();\n Serial.print(\"HX711 reading: \");\n Serial.println(reading);\n  } else {\n Serial.println(\"HX711 not found.\");\n  }\n\n delay(1000); "},{ "functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["Vcc","dat","clk","gnd"],listenOn:["dat"], gsNodeName: "loadcell_hx711").Finish() },
			{ 31, new ComponentDataBuilder("LED", true, "Output/LED", 1.5, 40, 50, typeof(RazorLED), codeForGen: new() { { "include", ""},{"global", "" }, { "setup", ""}, {"loopMain", "    digitalWrite(~\"anode\", !digitalRead(~\"anode\"));\n    delay(500);\n"},{"functions", "" }, { "delayLoop", ""}, {"delayTime", "" } }, pins: ["anode", "cathode"], listenOn: ["anode"], gsNodeName: "led").Property("value", false).Property("color", "red").Finish() },
			{ 32, new ComponentDataBuilder("7 - segment", true, "Output/LED", 1, 50, 85, typeof(RazorSevenSeg), paneHoverText: "Adafruit 0.56''", pins:["com1","com2","a","b","c","d","e","f","g","dp"], listenOn:["a","b","c","d","e","f","g","dp"], gsNodeName: "7segment").Property("values", new int[] { 0, 0, 0, 0, 0, 0, 0, 0 }).Finish() },
            { 33, new ComponentDataBuilder("Bar", false, "Output/LED", 1, 75, 75, paneHoverText: "Adafruit Bi - Color 24").Finish() },
            { 34, new ComponentDataBuilder("Matrix", false, "Output/LED", 1, 75, 75, paneHoverText: "MAX7219 / MAX7221").Finish() },
            { 35, new ComponentDataBuilder("Matrix", false, "Output/LED", 1, 75, 75, paneHoverText: "HT16K33").Finish() },
            { 36, new ComponentDataBuilder("RGB", true, "Output/LED", 1.5, 45, 80, typeof(RazorRGBLED), codeForGen: new() { { "include", ""},{"global", "const int blueLED = ~\"B\";\nconst int greenLED = ~\"G\";\nconst int redLED = ~\"R\";"}, {"setup", "  pinMode(blueLED, OUTPUT);\n  pinMode(greenLED, OUTPUT);\n  pinMode(redLED, OUTPUT);"}, {"loopMain", "  digitalWrite(blueLED, HIGH);\n  delay(1000);\n  digitalWrite(greenLED, HIGH);\n  delay(1000);\n  digitalWrite(redLED, HIGH);\n  delay(1000);\n  digitalWrite(blueLED, LOW);\n  delay(1000);\n  digitalWrite(greenLED, LOW);\n  delay(1000);\n  digitalWrite(redLED, LOW);\n  delay(1000);"},{"functions", "" }, { "delayLoop", ""}, {"delayTime", "" } }, pins: ["R", "G", "B", "cathode"],listenOn: ["R", "G", "B"], gsNodeName: "led_rgb").Property("ledRed", 0).Property("ledGreen", 0).Property("ledBlue", 0).Finish() },
            { 37, new ComponentDataBuilder("RGB module", false, "Output/LED", 1, 75, 75, paneHoverText: "KY - 009").Finish() },
            { 38, new ComponentDataBuilder("Laser LED", false, "Output/LED", 1, 75, 75).Finish() },
            { 39, new ComponentDataBuilder("LCD2004", false, "Output/Displays/LCD", 0.3, 320, 165, typeof(RazorLCD2004), codeForGen: new() { { "include", ""},{"global", "" }, { "setup", ""}, {"loopMain", "" }, { "functions", ""}, {"delayLoop", "" }, { "delayTime", ""}}, pins:["pin11","pin12","pin13","pin14","pin4","pin2","pin1","pin3","pin5","pin6","pin16","pin15"], gsNodeName: "lcd_2004_parallel").Property("text", "").Finish() },
            { 40, new ComponentDataBuilder("LCD2004 - I2C", false, "Output/Displays/LCD", 0.3, 320, 165, typeof(RazorLCD2004I2C), codeForGen: new(){{"include", "#include <Arduino.h>\n#include <Wire.h>\n#include <LiquidCrystal_PCF8574.h>"},{"global", "LiquidCrystal_PCF8574 lcd(0x27);  // set the LCD address to 0x27 (TI chip) or 0x3F (NPX Chip)\n\nint show = -1;\n\n// 2 custom characters\n\nbyte dotOff[] = { 0b00000, 0b01110, 0b10001, 0b10001,\n                  0b10001, 0b01110, 0b00000, 0b00000 };\nbyte dotOn[] = { 0b00000, 0b01110, 0b11111, 0b11111,\n                 0b11111, 0b01110, 0b00000, 0b00000 };"}, {"setup", "  int error;\n  Serial.println(\"LCD...\");\n\n  // wait on Serial to be available on Leonardo\n  while (!Serial)\n    ;\n  Serial.println(\"Probing for PCF8574 on address 0x27...\");\n  // See http://playground.arduino.cc/Main/I2cScanner how to test for a I2C device.\n  Wire.begin();\n  Wire.beginTransmission(0x27);\n  error = Wire.endTransmission();\n  Serial.print(\"Error: \");\n  Serial.print(error);\n  if (error == 0) {\n    Serial.println(\": LCD found.\");\n    show = 0;\n    lcd.begin(16, 2);  //  initialize the lcd\n    lcd.createChar(1, dotOff);\n    lcd.createChar(2, dotOn);\n  } else {\n    Serial.println(\": LCD not found.\");\n  } "}, {"loopMain", "  if (show == 0) {\n    lcd.setBacklight(255);\n    lcd.home();\n    lcd.clear();\n    lcd.print(\"Hello LCD\");\n    delay(1000);\n\n    lcd.setBacklight(0);\n    delay(400);\n    lcd.setBacklight(255);\n\n  } else if (show == 1) {\n    lcd.clear();\n    lcd.print(\"Cursor On\");\n    lcd.cursor();\n\n  } else if (show == 2) {\n    lcd.clear();\n    lcd.print(\"Cursor Blink\");\n    lcd.blink();\n\n  } else if (show == 3) {\n    lcd.clear();\n    lcd.print(\"Cursor OFF\");\n    lcd.noBlink();\n    lcd.noCursor();\n\n  } else if (show == 4) {\n    lcd.clear();\n    lcd.print(\"Display Off\");\n    lcd.noDisplay();\n\n  } else if (show == 5) {\n    lcd.clear();\n    lcd.print(\"Display On\");\n    lcd.display();\n\n  } else if (show == 7) {\n    lcd.clear();\n    lcd.setCursor(0, 0);\n    lcd.print(\"*** first line.\");\n    lcd.setCursor(0, 1);\n    lcd.print(\"*** second line.\");\n\n  } else if (show == 8) {\n    lcd.scrollDisplayLeft();\n  } else if (show == 9) {\n    lcd.scrollDisplayLeft();\n  } else if (show == 10) {\n    lcd.scrollDisplayLeft();\n  } else if (show == 11) {\n    lcd.scrollDisplayRight();\n\n  } else if (show == 12) {\n    lcd.clear();\n    lcd.print(\"write-\");\n\n  } else if (show == 13) {\n    lcd.clear();\n    lcd.print(\"custom 1:<\01>\");\n    lcd.setCursor(0, 1);\n    lcd.print(\"custom 2:<\02>\");\n\n  } else {\n    lcd.print(show - 13);\n  }  // if\n\n  delay(1400);\n  show = (show + 1) % 16;"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4"], gsNodeName: "lcd_2004_i2c").Property("text", "").Finish() },
            { 41, new ComponentDataBuilder("LCD1602", false, "Output/Displays/LCD", 0.35, 310, 140, typeof(RazorLCD1602), codeForGen:new(){{"include", ""},{"global", ""}, {"setup", ""}, {"loopMain", ""},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin11","pin12","pin13","pin14","pin4","pin2","pin1","pin3","pin5","pin6","pin16","pin15"], gsNodeName: "lcd_1602_parallel").Property("text", "").Finish() },
			{ 42, new ComponentDataBuilder("LCD1602 - I2C", true, "Output/Displays/LCD", 0.35, 310, 140, typeof(RazorLCD1602I2C), codeForGen:new(){{"include", "#include <Arduino.h>\n#include <Wire.h>\n#include <LiquidCrystal_PCF8574.h>"},{"global", "LiquidCrystal_PCF8574 lcd(0x27);  // set the LCD address to 0x27 (TI chip) or 0x3F (NPX Chip)\n\nint show = -1;\n\n// 2 custom characters\n\nbyte dotOff[] = { 0b00000, 0b01110, 0b10001, 0b10001,\n                  0b10001, 0b01110, 0b00000, 0b00000 };\nbyte dotOn[] = { 0b00000, 0b01110, 0b11111, 0b11111,\n                 0b11111, 0b01110, 0b00000, 0b00000 };"}, {"setup", "  int error;\n  Serial.println(\"LCD...\");\n\n  // wait on Serial to be available on Leonardo\n  while (!Serial)\n    ;\n  Serial.println(\"Probing for PCF8574 on address 0x27...\");\n  // See http://playground.arduino.cc/Main/I2cScanner how to test for a I2C device.\n  Wire.begin();\n  Wire.beginTransmission(0x27);\n  error = Wire.endTransmission();\n  Serial.print(\"Error: \");\n  Serial.print(error);\n  if (error == 0) {\n    Serial.println(\": LCD found.\");\n    show = 0;\n    lcd.begin(16, 2);  //  initialize the lcd\n    lcd.createChar(1, dotOff);\n    lcd.createChar(2, dotOn);\n  } else {\n    Serial.println(\": LCD not found.\");\n  } "}, {"loopMain", "  if (show == 0) {\n    lcd.setBacklight(255);\n    lcd.home();\n    lcd.clear();\n    lcd.print(\"Hello LCD\");\n    delay(1000);\n\n    lcd.setBacklight(0);\n    delay(400);\n    lcd.setBacklight(255);\n\n  } else if (show == 1) {\n    lcd.clear();\n    lcd.print(\"Cursor On\");\n    lcd.cursor();\n\n  } else if (show == 2) {\n    lcd.clear();\n    lcd.print(\"Cursor Blink\");\n    lcd.blink();\n\n  } else if (show == 3) {\n    lcd.clear();\n    lcd.print(\"Cursor OFF\");\n    lcd.noBlink();\n    lcd.noCursor();\n\n  } else if (show == 4) {\n    lcd.clear();\n    lcd.print(\"Display Off\");\n    lcd.noDisplay();\n\n  } else if (show == 5) {\n    lcd.clear();\n    lcd.print(\"Display On\");\n    lcd.display();\n\n  } else if (show == 7) {\n    lcd.clear();\n    lcd.setCursor(0, 0);\n    lcd.print(\"*** first line.\");\n    lcd.setCursor(0, 1);\n    lcd.print(\"*** second line.\");\n\n  } else if (show == 8) {\n    lcd.scrollDisplayLeft();\n  } else if (show == 9) {\n    lcd.scrollDisplayLeft();\n  } else if (show == 10) {\n    lcd.scrollDisplayLeft();\n  } else if (show == 11) {\n    lcd.scrollDisplayRight();\n\n  } else if (show == 12) {\n    lcd.clear();\n    lcd.print(\"write-\");\n\n  } else if (show == 13) {\n    lcd.clear();\n    lcd.print(\"custom 1:<\01>\");\n    lcd.setCursor(0, 1);\n    lcd.print(\"custom 2:<\02>\");\n\n  } else {\n    lcd.print(show - 13);\n  }  // if\n\n  delay(1400);\n  show = (show + 1) % 16;"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4"], gsNodeName: "lcd_1602_i2c").Property("text", "").Property("backlight", false).Property("blink", false).Property("cursor", false).Property("cursorX", 0).Property("cursorY", 0).Finish() },
            { 43, new ComponentDataBuilder("SH1106 OLED - SPI", false, "Output/Displays/OLED", 1, 75, 75).Finish() },
			{ 44, new ComponentDataBuilder("SH1106 OLED - I2C", false, "Output/Displays/OLED", 1, 75, 75).Finish() },
			{ 45, new ComponentDataBuilder("Direct - SG90", true, "Output/Motors/Servo Motor", 0.65, 175, 120, typeof(RazorServo), codeForGen:new(){{"include", "#include <Servo.h>"},{"global", "Servo myservo;  // create servo object to control a servo\nint pos = 0;    // variable to store the servo position"}, {"setup", "  myservo.attach(~\"orange\");"}, {"loopMain", "  for (pos = 0; pos <= 180; pos += 1) { // goes from 0 degrees to 180 degrees\n    // in steps of 1 degree\n    myservo.write(pos);              // tell servo to go to position in variable 'pos'\n    delay(15);                       // waits 15 ms for the servo to reach the position\n  }\n  for (pos = 180; pos >= 0; pos -= 1) { // goes from 180 degrees to 0 degrees\n    myservo.write(pos);              // tell servo to go to position in variable 'pos'\n    delay(15);                       // waits 15 ms for the servo to reach the position\n  }"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["brown","red","orange"],listenOn:["orange"], gsNodeName: "servo_9g_direct").Property("angle", 0).Finish() },
            { 46, new ComponentDataBuilder("Direct - DS-7001HV", false, "Output/Motors/Servo Motor", 1, 75, 75, codeForGen:new(){{"include", "#include <servo.h>"},{"global", "Servo myservo;  // create servo object to control a servo\nint pos = 0;    // variable to store the servo position"}, {"setup", "  myservo.attach(~\"orange\");"}, {"loopMain", "  for (pos = 0; pos <= 180; pos += 1) { // goes from 0 degrees to 180 degrees\n    // in steps of 1 degree\n    myservo.write(pos);              // tell servo to go to position in variable 'pos'\n    delay(15);                       // waits 15 ms for the servo to reach the position\n  }\n  for (pos = 180; pos >= 0; pos -= 1) { // goes from 180 degrees to 0 degrees\n    myservo.write(pos);              // tell servo to go to position in variable 'pos'\n    delay(15);                       // waits 15 ms for the servo to reach the position\n  }"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["orange","red","brown"], gsNodeName: "servo_direct").Finish() },
            { 47, new ComponentDataBuilder("Driver - SG90", false, "Output/Motors/Servo Motor", 1, 75, 75, paneHoverText: "PCA9684", codeForGen:new(){{"include", "#include <wire.h>\n#include <Adafruit_PWMServoDriver.h>"},{"global", "// called this way, it uses the default address 0x40\nAdafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver();\n// you can also call it with a different address you want\n//Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x41);\n// you can also call it with a different address and I2C interface\n//Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40, Wire);\n\n// Depending on your servo make, the pulse width min and max may vary, you \n// want these to be as small/large as possible without hitting the hard stop\n// for max range. You'll have to tweak them as necessary to match the servos you\n// have!\n#define SERVOMIN  150 // This is the 'minimum' pulse length count (out of 4096)\n#define SERVOMAX  600 // This is the 'maximum' pulse length count (out of 4096)\n#define USMIN  600 // This is the rounded 'minimum' microsecond length based on the minimum pulse of 150\n#define USMAX  2400 // This is the rounded 'maximum' microsecond length based on the maximum pulse of 600\n#define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates\n\n// our servo # counter\nuint8_t servonum = 0;"}, {"setup", "  Serial.println(\"8 channel Servo test!\");\n\n  pwm.begin();\n  pwm.setOscillatorFrequency(27000000);\n  pwm.setPWMFreq(SERVO_FREQ);  // Analog servos run at ~50 Hz updates\n\n  delay(10);"}, {"loopMain", "  // Drive each servo one at a time using setPWM()\n  Serial.println(servonum);\n  for (uint16_t pulselen = SERVOMIN; pulselen < SERVOMAX; pulselen++) {\n    pwm.setPWM(servonum, 0, pulselen);\n  }\n\n  delay(500);\n  for (uint16_t pulselen = SERVOMAX; pulselen > SERVOMIN; pulselen--) {\n    pwm.setPWM(servonum, 0, pulselen);\n  }\n\n  delay(500);\n\n  // Drive each servo one at a time using writeMicroseconds(), it's not precise due to calculation rounding!\n  // The writeMicroseconds() function is used to mimic the Arduino Servo library writeMicroseconds() behavior. \n  for (uint16_t microsec = USMIN; microsec < USMAX; microsec++) {\n    pwm.writeMicroseconds(servonum, microsec);\n  }\n\n  delay(500);\n  for (uint16_t microsec = USMAX; microsec > USMIN; microsec--) {\n    pwm.writeMicroseconds(servonum, microsec);\n  }\n\n  delay(500);\n\n  servonum++;\n  if (servonum > 7) servonum = 0; // Testing the first 8 servo channels"},{"functions", "// You can use this function if you'd like to set the pulse length in seconds\n// e.g. setServoPulse(0, 0.001) is a ~1 millisecond pulse width. It's not precise!\nvoid setServoPulse(uint8_t n, double pulse) {\n  double pulselength;\n  \n  pulselength = 1000000;   // 1,000,000 us per second\n  pulselength /= SERVO_FREQ;   // Analog servos run at ~60 Hz updates\n  Serial.print(pulselength); Serial.println(\" us per period\"); \n  pulselength /= 4096;  // 12 bits of resolution\n  Serial.print(pulselength); Serial.println(\" us per bit\"); \n  pulse *= 1000000;  // convert input seconds to us\n  pulse /= pulselength;\n  Serial.println(pulse);\n  pwm.setPWM(n, 0, pulse);\n}"}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["orange","red","brown","pwm0","V+","gnd","5V","scl","sda","pca9685","pwm1","pwm2","pwm3","pwm4","pwm5"], gsNodeName: "servo_9g_pca9685").Finish() },
            { 48, new ComponentDataBuilder("Driver - DS-7001HV", false, "Output/Motors/Servo Motor", 1, 75, 75, paneHoverText: "PCA9685", codeForGen:new(){{"include", "#include <wire.h>\n#include <Adafruit_PWMServoDriver.h>"},{"global", "// called this way, it uses the default address 0x40\nAdafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver();\n// you can also call it with a different address you want\n//Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x41);\n// you can also call it with a different address and I2C interface\n//Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40, Wire);\n\n// Depending on your servo make, the pulse width min and max may vary, you \n// want these to be as small/large as possible without hitting the hard stop\n// for max range. You'll have to tweak them as necessary to match the servos you\n// have!\n#define SERVOMIN  150 // This is the 'minimum' pulse length count (out of 4096)\n#define SERVOMAX  600 // This is the 'maximum' pulse length count (out of 4096)\n#define USMIN  600 // This is the rounded 'minimum' microsecond length based on the minimum pulse of 150\n#define USMAX  2400 // This is the rounded 'maximum' microsecond length based on the maximum pulse of 600\n#define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates\n\n// our servo # counter\nuint8_t servonum = 0;"}, {"setup", "  Serial.println(\"8 channel Servo test!\");\n\n  pwm.begin();\n  pwm.setOscillatorFrequency(27000000);\n  pwm.setPWMFreq(SERVO_FREQ);  // Analog servos run at ~50 Hz updates\n\n  delay(10);"}, {"loopMain", "  // Drive each servo one at a time using setPWM()\n  Serial.println(servonum);\n  for (uint16_t pulselen = SERVOMIN; pulselen < SERVOMAX; pulselen++) {\n    pwm.setPWM(servonum, 0, pulselen);\n  }\n\n  delay(500);\n  for (uint16_t pulselen = SERVOMAX; pulselen > SERVOMIN; pulselen--) {\n    pwm.setPWM(servonum, 0, pulselen);\n  }\n\n  delay(500);\n\n  // Drive each servo one at a time using writeMicroseconds(), it's not precise due to calculation rounding!\n  // The writeMicroseconds() function is used to mimic the Arduino Servo library writeMicroseconds() behavior. \n  for (uint16_t microsec = USMIN; microsec < USMAX; microsec++) {\n    pwm.writeMicroseconds(servonum, microsec);\n  }\n\n  delay(500);\n  for (uint16_t microsec = USMAX; microsec > USMIN; microsec--) {\n    pwm.writeMicroseconds(servonum, microsec);\n  }\n\n  delay(500);\n\n  servonum++;\n  if (servonum > 7) servonum = 0; // Testing the first 8 servo channels"},{"functions", "// You can use this function if you'd like to set the pulse length in seconds\n// e.g. setServoPulse(0, 0.001) is a ~1 millisecond pulse width. It's not precise!\nvoid setServoPulse(uint8_t n, double pulse) {\n  double pulselength;\n  \n  pulselength = 1000000;   // 1,000,000 us per second\n  pulselength /= SERVO_FREQ;   // Analog servos run at ~60 Hz updates\n  Serial.print(pulselength); Serial.println(\" us per period\"); \n  pulselength /= 4096;  // 12 bits of resolution\n  Serial.print(pulselength); Serial.println(\" us per bit\"); \n  pulse *= 1000000;  // convert input seconds to us\n  pulse /= pulselength;\n  Serial.println(pulse);\n  pwm.setPWM(n, 0, pulse);\n}"}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["orange","red","brown","pwm0","V+","gnd","5V","scl","sda","pca9685","pwm1","pwm2","pwm3","pwm4","pwm5"], gsNodeName: "servo_pca9685").Finish() },
            { 49, new ComponentDataBuilder("Direct - Motor", false, "Output/Motors/DC Motor", 1, 75, 75).Finish() },
			{ 50, new ComponentDataBuilder("Driver - Motor", false, "Output/Motors/DC Motor", 1, 75, 75, paneHoverText: "DRV8833").Finish() },
			{ 51, new ComponentDataBuilder("Brushless ESC - Motor", false, "Output/Motors/DC Motor", .25, 40, 55, typeof(RazorESCBLDCMotor), codeForGen:new(){{"include", "#include <wire.h>\n#include <Adafruit_PWMServoDriver.h>"},{"global", "// called this way, it uses the default address 0x40\nAdafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver();\n// you can also call it with a different address you want\n//Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x41);\n// you can also call it with a different address and I2C interface\n//Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40, Wire);\n\n// Depending on your servo make, the pulse width min and max may vary, you \n// want these to be as small/large as possible without hitting the hard stop\n// for max range. You'll have to tweak them as necessary to match the servos you\n// have!\n#define SERVOMIN  150 // This is the 'minimum' pulse length count (out of 4096)\n#define SERVOMAX  600 // This is the 'maximum' pulse length count (out of 4096)\n#define USMIN  600 // This is the rounded 'minimum' microsecond length based on the minimum pulse of 150\n#define USMAX  2400 // This is the rounded 'maximum' microsecond length based on the maximum pulse of 600\n#define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates\n\n// our servo # counter\nuint8_t servonum = 0;"}, {"setup", "  Serial.println(\"8 channel Servo test!\");\n\n  pwm.begin();\n  pwm.setOscillatorFrequency(27000000);\n  pwm.setPWMFreq(SERVO_FREQ);  // Analog servos run at ~50 Hz updates\n\n  delay(10);"}, {"loopMain", "  // Drive each servo one at a time using setPWM()\n  Serial.println(servonum);\n  for (uint16_t pulselen = SERVOMIN; pulselen < SERVOMAX; pulselen++) {\n    pwm.setPWM(servonum, 0, pulselen);\n  }\n\n  delay(500);\n  for (uint16_t pulselen = SERVOMAX; pulselen > SERVOMIN; pulselen--) {\n    pwm.setPWM(servonum, 0, pulselen);\n  }\n\n  delay(500);\n\n  // Drive each servo one at a time using writeMicroseconds(), it's not precise due to calculation rounding!\n  // The writeMicroseconds() function is used to mimic the Arduino Servo library writeMicroseconds() behavior. \n  for (uint16_t microsec = USMIN; microsec < USMAX; microsec++) {\n    pwm.writeMicroseconds(servonum, microsec);\n  }\n\n  delay(500);\n  for (uint16_t microsec = USMAX; microsec > USMIN; microsec--) {\n    pwm.writeMicroseconds(servonum, microsec);\n  }\n\n  delay(500);\n\n  servonum++;\n  if (servonum > 7) servonum = 0; // Testing the first 8 servo channels"},{"functions", "// You can use this function if you'd like to set the pulse length in seconds\n// e.g. setServoPulse(0, 0.001) is a ~1 millisecond pulse width. It's not precise!\nvoid setServoPulse(uint8_t n, double pulse) {\n  double pulselength;\n  \n  pulselength = 1000000;   // 1,000,000 us per second\n  pulselength /= SERVO_FREQ;   // Analog servos run at ~60 Hz updates\n  Serial.print(pulselength); Serial.println(\" us per period\"); \n  pulselength /= 4096;  // 12 bits of resolution\n  Serial.print(pulselength); Serial.println(\" us per bit\"); \n  pulse *= 1000000;  // convert input seconds to us\n  pulse /= pulselength;\n  Serial.println(pulse);\n  pwm.setPWM(n, 0, pulse);\n}"}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["bat+","bat-","L3","L2","L1","orange","red","brown","pwm1","V+","gnd","pca9685","pwm0","pwm2","pwm3","pwm4","pwm5","5V","scl","sda"], gsNodeName: "esc_pca9685").Finish() },
            { 52, new ComponentDataBuilder("28BYJ-48", false, "Output/Motors/Stepper Motor", 1, 75, 75, paneHoverText: "Includes driver").Finish() },
			{ 53, new ComponentDataBuilder("Nema-17", false, "Output/Motors/Stepper Motor", 0.6, 165, 180, typeof(RazorStepperMotor), paneHoverText: "Includes driver", codeForGen:new(){{"include", "#include <Stepper.h>"},{"global", "const int stepsPerRevolution = 200;  // change this to fit the number of steps per revolution\n// for your motor\n\n// initialize the stepper library on pins 8 through 11:\nStepper myStepper(stepsPerRevolution, ~“in1\", ~\"in2\", ~\"in3\", ~\"in4\");"}, {"setup", "  // set the speed at 60 rpm:\n  myStepper.setSpeed(60);"}, {"loopMain", "  // step one revolution  in one direction:\n  Serial.println(\"clockwise\");\n  myStepper.step(stepsPerRevolution);\n  delay(500);\n\n  // step one revolution in the other direction:\n  Serial.println(\"counterclockwise\");\n  myStepper.step(-stepsPerRevolution);\n  delay(500);"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4","out4","out3","out2","out1","l298n","V+","ENB","5V","ENA","gnd","in4","in3","in2","in1"], gsNodeName: "stepper_nema_l298n").Finish() },
            { 54, new ComponentDataBuilder("Speaker", false, "Output/Others", 2, 75, 75, typeof(RazorSpeaker), paneHoverText: "LM386", codeForGen:new(){{"include", "#include \"TMRpcm.h\" //PCM/WAV Audio playback Play WAV audio files from SD card"},{"global", "TMRpcm audio; //Lib object is named \"audio\""}, {"setup", "  audio.speakerPin = ~\"digital_in\"; \n  audio.quality(0);          //Set 1 for 2x oversampling, 0 for normal. Must be called before playback.\n  audio.setVolume(5);        //0 to 7. Set volume level"}, {"loopMain", "  if(!audio.isPlaying())//returns 1 if music playing, 0 if not\n  {\n    audio.play(\"filename\",30); //REPLACE \"filenames\" with \"FILENAME.wav\" or \"FILENAME.pcm\" on SD card.plays a file starting at 30 seconds into the track\n    audio.loop(1);             //0 or 1. Can be changed during playback for full control of looping. \n  };         \n  // audio.play(\"filename\");    //plays a file\n  // audio.play(F(\"filename\")); //plays a file storing the string in program memory instead of RAM\n  // audio.disable();           //disables the timer on output pin and stops the music\n  // audio.stopPlayback();      //stops the music, but leaves the timer running\n  audio.volume(0);           //1(up) or 0(down) to control volume\n  delay(2000);               //play for 2 seconds\n  audio.pause();             //pauses/unpauses playback\n  delay(2000);               //pause for 2 seconds\n  audio.pause();             //resume"},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["V-","V+","out-","out+","lm386","pin1","pin2","pin3","pin4"], gsNodeName: "speaker_lm386").Finish() },
            { 55, new ComponentDataBuilder("Buzzer", false, "Output/Others", 1.4, 70, 75).Finish() },
			{ 56, new ComponentDataBuilder("Encoder", false, "Others", 1, 75, 75, paneHoverText: "E6B2-CWZ3E", codeForGen:new(){{"include", ""},{"global", "Encoder encoder = Encoder(~\"A\", ~\"B\", 1024);"}, {"setup", "  //Encoder===========================\n  // enable/disable quadrature mode\n  encoder.quadrature = Quadrature::ON;\n  // check if you need internal pullups\n  encoder.pullup = Pullup::USE_EXTERN;\n  // initialize encoder hardware\n  encoder.init();\n  // hardware interrupt enable\n  encoder.enableInterrupts(doA, doB);\n  Serial.println(\"Encoder ready\");"}, {"loopMain", "  // update the sensor values\n  encoder.update();\n  Serial.print(encoder.getAngle() * 180 / 3.1416);\n  Serial.print(\"\t\");\n  Serial.println(encoder.getVelocity());"},{"functions", "void doA() {\n  encoder.handleA();\n}\nvoid doB() {\n  encoder.handleB();\n}"}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["A","B","Z","gnd","5V"], gsNodeName: "encoder").Finish() },
			{ 57, new ComponentDataBuilder("Voltage regulator", false, "Others", 1, 75, 75, paneHoverText: "LM2596", pins:["V+","V-"], gsNodeName: "lm2596").Finish() },
			{ 58, new ComponentDataBuilder("Bluetooth Module", false, "Others", 1, 75, 75, paneHoverText: "HM-10", codeForGen:new(){{"include", ""},{"global", ""}, {"setup", ""}, {"loopMain", ""},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}}, pins:["pin1","pin2","pin3","pin4"], gsNodeName: "hm-10").Finish() },
			{ 59, new ComponentDataBuilder("resistor", true, "", 1, 75, 75, typeof(RazorResistor)).Property("ohms", 1000).Finish() },
			{ 60, new ComponentDataBuilder("stepper driver", false, "", 1, 75, 75).Finish() },
			{ 61, new ComponentDataBuilder("Arcade push button", false, "Input/Buttons and Switches", 1, 75, 75, typeof(RazorPushButton), "Push Button", codeForGen:new(){{"include", ""},{"global", ""}, {"setup", ""}, {"loopMain", ""},{"functions", ""}, {"delayLoop", ""}, {"delayTime", ""}},pins:["digital", "gnd"],gsNodeName:"arcade-pushbutton").Finish()},
			{ 62, new ComponentDataBuilder("KY-012 Active Buzzer", true, "Output/Sound", 1, 18.5, 19.154, typeof(RazorKY012), codeForGen: new() { {"include", ""}, {"global", "const int buzzerPin = ~\"S\";  // Signal pin for the buzzer"}, {"setup", "pinMode(buzzerPin, OUTPUT);  // Set buzzer pin as output"}, {"loopMain", "digitalWrite(buzzerPin, HIGH);  // Turn buzzer on\n  delay(4000);                    // Wait 4 seconds\n  digitalWrite(buzzerPin, LOW);    // Turn buzzer off\n  delay(2000);                    // Wait 2 seconds"}, {"functions", ""}, {"delayLoop", ""}, {"delayTime", ""} }, pins: new List<string> { "S", "GND" }, listenOn: new List<string> { "S" }, gsNodeName: "ky012").Finish() }

		};

	}
}
