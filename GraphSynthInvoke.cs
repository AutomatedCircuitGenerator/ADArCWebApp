using ADArCWebApp;
using GraphSynth.Representation;
using GraphSynth.Search;
using Microsoft.AspNetCore.Components;
using System.Linq;
using System.Xml.Linq;

namespace ADArCWebApp
{
    public static class GraphSynthInvoke
    {
        //Dictionary<string, ruleSet> rulesets = new() {
        //    {"add", null },
        //    {"connect1", null}
        //};
        static Dictionary<string, ruleSet> rulesets = RuleSetMap.rulesets;

        //inputs from user selecting components
        public static List<string> inputs = new();

        static designGraph seed = new();

        private static List<node>? _arduinoNodes;

        public static void destroyGraph()
        {
            seed = new();
        }

        /// <summary>
        /// This function sets up the seed graph from the inputs.
        /// This system is not great.
        /// TODO: improve.
        /// </summary>
        /// <param name="Inputs">A list of graphsynth node names with their "user_" prefix missing.</param>
        public static void makeGraph(List<string> Inputs)
        {
            //designGraph Graph = new designGraph();
            inputs.AddRange(Inputs);
            for (int i = 0; i < Inputs.Count; i++)
            {
                node n = new();
                n.setLabel(0, "user_" + Inputs[i]);
                seed.addNode(n);
                //seed.nodes[i].setLabel(0, "user_"+inputs[i]);
            }
        }

        //apply the GraphSynth rules
        public static void recg_apply(List<string>? fInp = null)
        {
            if (fInp != null)
            {
                makeGraph(fInp);
            }

            if (seed.nodes.Count == 0)
            {
                makeGraph(inputs);
            }

            ruleSet r = new();
            ruleSet connect = rulesets["CONNECT"];
            for (int i = 0; i < connect.rules.Count; i++)
            {
                for (int j = 0; j < inputs.Count; j++)
                {
                    //edit the names to avoid adding rules that have common words in their name
                    if (inputs[j].Contains("servo") && inputs[j].Contains("direct"))
                    {
                        inputs[j] = "servo";
                    }
                    else if (inputs[j].Contains("pca9685"))
                    {
                        inputs[j] = "pca9685";
                    }
                    else if (inputs[j].Contains("l298n"))
                    {
                        inputs[j] = "l298n";
                    }
                    else if (inputs[j].Contains("a4988"))
                    {
                        inputs[j] = "a4988";
                    }
                    else if (inputs[j].Contains("lm386"))
                    {
                        inputs[j] = "lm386";
                    }
                    else if (inputs[j].Contains("hx711"))
                    {
                        inputs[j] = "hx711";
                    }

                    if (connect.rules[i].name.Contains(inputs[j]))
                    {
                        if (!r.rules.Contains(connect.rules[i]))
                        {
                            r.Add(connect.rules[i]);
                            Console.WriteLine(connect.rules[i].name);
                        }
                    }
                }
            }

            //Console.WriteLine(r.rules.Count);
            List<option> options = rulesets["ADD"].recognize(seed, true);
            //List<option> options = r.recognize(seed, true);

            while (options.Count > 0)
            {
                options[0].apply(seed, null);
                options = rulesets["ADD"].recognize(seed, true);
            }

            // this entire region is essentially a replacement to the "recognize/apply" algorithm for setting
            // up the connections for the newly created component. This was required due to performance issues
            // on larger boards (Mega) where the number of options generated by recognize was too high.
            #region connect 
            // first we find the arduino nodes. these may have already been cached from a previous recg_apply call
            if (_arduinoNodes == null) // Arduino nodes have not been cached
            { 
                var arduinoNode = seed.nodes.Find(n => n.localLabels.Contains("arduino"));

                if (arduinoNode == null)
                {
                    Console.WriteLine("No arduino node was found");
                    return;
                }
                _arduinoNodes = arduinoNode.arcsTo.Select(arc => arc.From)
                    .Concat(arduinoNode.arcsFrom.Select(arc => arc.To))
                    .ToList();
            }
            // next we find the nodes of the newly created component. 
            // this is done iterating the nodes list in reverse, because it is likely
            // to have been added at the end.
            node? userNode = null;
            for (var i = seed.nodes.Count - 1; i >= 0; i--) 
            {
                var labels = seed.nodes[i].localLabels;
                if  (labels.Any(l => l.Contains("user_")) && !labels.Any(l => l.Contains("localId:")))
                {
                    userNode = seed.nodes[i];
                    break;
                }
            }

            if (userNode == null)
            {
                Console.WriteLine("No user_ node for the new component was found");
                return;
            }
            
            var componentNode = userNode.arcsTo.Count > 0 ? userNode.arcsTo[0].From : userNode.arcsFrom[0].To;
            var componentNodes = new List<node>();

            // start bfs from the component node to find all of its associated nodes
            var visited = new HashSet<node>();
            var queue = new Queue<node>();
            queue.Enqueue(componentNode);
            visited.Add(componentNode);
            while (queue.Count > 0)
            {
                var currentNode = queue.Dequeue();
                componentNodes.Add(currentNode);

                // Get all connected nodes (both arcsTo and arcsFrom)
                var connectedNodes = currentNode.arcsTo.Select(arc => arc.From)
                    .Concat(currentNode.arcsFrom.Select(arc => arc.To));

                foreach (var connectedNode in connectedNodes)
                {
                    if (visited.Add(connectedNode))
                    {
                        queue.Enqueue(connectedNode);
                    }
                }
            }

            // finally, we can start applying the rules
            foreach (var rule in r.rules)
            {
                // rule.R in this case is the graph of the rule AFTER the application
                foreach (var arc in rule.R.arcs)
                {
                    // only look at arcs that represent new connections
                    if (!arc.localLabels.Contains("connection")) continue;
                    var isFromArduino = (arc.From.arcsFrom.Any(a => a.To.localLabels.Contains("arduino")) ||
                                         arc.From.arcsTo.Any(a => a.From.localLabels.Contains("arduino")));

                    // this is to figure out which side of the arc is the arduino's pin and which is the component's
                    var ruleArduinoNode = isFromArduino ? arc.From : arc.To;
                    var ruleComponentNode = isFromArduino ? arc.To : arc.From;

                    // we do a lot of comparisons using these labels later, so put them in a HashSet 
                    // will be more performant on checks like Contains
                    var ruleArduinoNodeLabels = new HashSet<string>(ruleArduinoNode.localLabels);
                    var ruleComponentNodeLabels = new HashSet<string>(ruleComponentNode.localLabels);
                    // remove the connected labels, remembering whether it was present in the arduino node (unique connection)
                    var uniqueConnection = ruleArduinoNodeLabels.Contains("connected");
                    ruleComponentNodeLabels.Remove("connected");
                    ruleArduinoNodeLabels.Remove("connected");

                    // finding the equivelant nodes in the actual graph
                    var matchedArduinoNode = _arduinoNodes.Find(n =>
                        ruleArduinoNodeLabels.IsSubsetOf(n.localLabels) && !n.localLabels.Contains("connected"));
                    var matchedComponentNode = componentNodes.Find(n =>
                        ruleComponentNodeLabels.IsSubsetOf(n.localLabels) && !n.localLabels.Contains("connected"));

                    // if we find a match, create the connection
                    if (matchedArduinoNode != null && matchedComponentNode != null)
                    {
                        // if the connection is intended to be unique (marked as "connected") we add the label back
                        if (uniqueConnection)
                        {
                            matchedArduinoNode.localLabels.Add("connected");
                        }
                        var newArc = new arc
                        {
                            From = matchedComponentNode,
                            To = matchedArduinoNode,
                            localLabels = arc.localLabels
                        };
                        seed.addArc(newArc, matchedComponentNode, matchedArduinoNode);
                    }
                }
            }
            #endregion
        }

        /// <summary>
        /// This function removes the component from the seed graph.
        /// </summary>
        /// <param name="n">A node that belongs to the component being removed.</param>
        static public void removeComp(node n)
        {
            if (n == null)
            {
                return;
            }

            string localId = n.localLabels.Find(s => s.StartsWith("localId:"));
            foreach (var nodeToRemove in seed.nodes.Where(n => n.localLabels.Contains(localId)).ToList())
            {
                foreach (arc arcToRemove in nodeToRemove.arcs.ToList())
                {
                    arcToRemove.otherNode(nodeToRemove).localLabels.Remove("connected");
                    seed.removeArc(arcToRemove);
                }

                seed.removeNode(nodeToRemove);
            }
        }

        /// <summary>
        /// Returns the arcs of seed
        /// </summary>
        /// <returns>A list of arcs</returns>
        static public List<arc> GetArcs()
        {
            return seed.arcs;
        }

        /// <summary>
        /// Returns the nodes of seed
        /// </summary>
        /// <returns>A list of nodes</returns>
        static public List<node> GetNodes()
        {
            return seed.nodes;
        }
    }
}