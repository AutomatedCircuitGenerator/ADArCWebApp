@page "/"
@using GraphSynth.Representation
@inject IJSRuntime JsRuntime

<PageTitle>Index</PageTitle>
<body>
	<script>
		window.triggerClick = (elt) => elt.click();
	</script>
	<script suppress-error="BL9992" type="module" src="build/build.js"></script>
	<button @ref="refresh" hidden="hidden" @onclick="StateChanged">refresh</button>
	<div class="page">
		<div class="toolbar">
			<img class="logo" src="images/adarc-logo.001.png" alt="adarc-logo">
			<span class="adarc-text">ADArC</span>
			<div class="center-toolbar">
				<button class="toolbar-button">
					<span>📂 Save</span>
				</button>
				<button class="toolbar-button">
					<span>❓Help</span>
				</button>
				<button class="toolbar-button" @onclick="ToggleRunStop">
					<span>@runStopText</span>
				</button>
			</div>
		</div>
		

		<div class="page-content" @onmousedown="checkForCardDrag" @onmousemove="dragCardIfPossible" @onmouseup="addToCanvasIfNecessary">
			<div class="main-canvas">
				<MainCanvas comps=@(comps) handleMouseEnter="()=>allowDrop=true" handleMouseLeave="()=>allowDrop=false"></MainCanvas>
			</div>
			<div class="sidebar" style="width: 25%; left: @(leftPaneAlign+"%")">
				<div class="expand-button expand-button-left" @onclick="ToggleLeftSidebar" style="left:100%;">
					<span>◀</span>
				</div>
				<ComponentPane host="@this"></ComponentPane>
			</div>
			<div id="mover" style="pointer-events:none; position:absolute; top:@(moverOffsetTop)px; left:@(moverOffsetLeft)px; transform:translate(-50%, -50%); visibility:@isVisible; width:@(ComponentDeclarations.components[moverID].rightOffset)px; height:@(ComponentDeclarations.components[moverID].bottomOffset)px;">
				<VaryingComponent disableBorder=true posAbolute="false" individualData="new(moverID, ComponentDeclarations.components[moverID].defaultVal, new(), 0, 0)" objId="@moverID" zoomFactor="buildCanvas?.zoomFactor == null? 1: buildCanvas.zoomFactor" DragStart="()=>{}" DragProgress="()=>{}" DragEnd="()=>{}"></VaryingComponent>
			</div>
			<div class="sidebar-right" style="width: 40%; right: @(rightPaneAlign+"%")">
				<div class="expand-button expand-button-right" @onclick="ToggleRightSidebar" style="right:100%;">
					<span>◀</span>
				</div>
				<CodePane></CodePane>
			</div>
		</div>
	</div>
</body>


@code{
	bool isLeftExpanded = true;
	bool isRightExpanded = false;
	int leftPaneAlign => isLeftExpanded ? 0 : -23;
	int rightPaneAlign => isRightExpanded ? 0 : -37;
	string runStopText => isRunning ? "🟥 Stop" : "▶ Run";
	bool isRunning = false;

	void ToggleLeftSidebar()
	{
		isLeftExpanded = !isLeftExpanded;
		isRightExpanded = false;
	}

	void ToggleRightSidebar()
	{
		isRightExpanded = !isRightExpanded;
		isLeftExpanded = false;
	}
	void ToggleRunStop()
	{
		isRunning = !isRunning;
	}

	public Index()
	{
		app = this;
	}

	public void StateChanged()
	{
		Console.WriteLine("targetcardId " + targetCardComponentId);
		StateHasChanged();	
	}

	async Task triggerRender()
	{
		await JsRuntime.InvokeAsync<object>("triggerClick", refresh);
	}

	private int localIds = 0;

	public static Dictionary<int, ComponentInstance> comps = new()
	{
	};


	public int selectedComponent = -1;

	public static Index? app;
	public static MainCanvas? buildCanvas;
	public static readonly int defaultScreenWidth = 1920;
	public static double currentRatio = 1;

	public static ElementReference? refresh;



	protected async override Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{

			AppInterop.runtime = JsRuntime;
			AppInterop.jsModule = await AppInterop.getModuleWrapper();

			AppInterop.updateScreenWidthRatio(await AppInterop.getWindowWidth());
			AppInterop.startSimWrapper();
		}
	}



	#region component pane integration
	private int targetCardComponentId = -1;
	private int moverID => targetCardComponentId == -1 ? 1 : targetCardComponentId;
	private string isVisible = "hidden";
	private bool allowDrop = false;

	private double moverOffsetTop = 0;
	private double moverOffsetLeft = 0;

	public void setTargetID(int id)
	{
		targetCardComponentId = id;
	}


	private void checkForCardDrag(MouseEventArgs e)
	{
		if (e.Button == 0 && targetCardComponentId != -1)
		{
			isVisible = "visible";
			moverOffsetLeft = e.ClientX;
			moverOffsetTop = e.ClientY;
		}
	}

	private void dragCardIfPossible(MouseEventArgs e)
	{
		if (targetCardComponentId != -1)
		{
			moverOffsetLeft = e.ClientX;
			moverOffsetTop = e.ClientY;
		}
	}

	public void addToCanvasIfNecessary(MouseEventArgs e)
	{
		if (targetCardComponentId != -1)
		{
			isVisible = "hidden";
			if (allowDrop)
			{
				++localIds;
				var d = ComponentDeclarations.components[targetCardComponentId];
				var n = new node();//label with localId (easy tracking)
				n.localLabels.Add("localId:" + localIds);


				//TODO: uncomment:GraphSynthInvoke.recg_apply(d.gsNodeName);

				n.arcs.ForEach(a => a.localLabels.Add("localId:" + localIds));
				n.arcs.ForEach(a => ((arc)a).otherNode(n).localLabels.Add("localId:" + localIds));
				comps.Add(localIds, buildCanvas.unZoom(new(targetCardComponentId, d.defaultVal, n, e.ClientX - (.5*d.rightOffset), e.ClientY - (.5*d.bottomOffset)-50)));//50 is height of toolbar
				foreach (var c in comps.Values)
				{
					updatePinBindings(c);	//keep an eye on this. could be not good for performance.
				}
			}
			moverOffsetLeft = 0;
			moverOffsetTop = 0;
			targetCardComponentId = -1;
			// test();
		}
	}
	#endregion

	private readonly List<string> ruleNames = new();
	private readonly double totalRules = 19.0;
	private string fileToLoad = "";
	private double loadPercent = 0;
	protected override async Task OnInitializedAsync()
	{
		// loads rulesets
		// allRulesLoaded = false;
		// ruleNames.Add("BondGraphRuleset"); //58
		// ruleNames.Add("SimplificationRuleset"); //28
		// ruleNames.Add("DirRuleset"); //5
		// ruleNames.Add("newDirectionRuleSet_2"); //17
		// ruleNames.Add("DirRuleset3"); //4
		// ruleNames.Add("Simplification2"); //32
		// ruleNames.Add("NewCausalityMethodRuleset"); //6
		// ruleNames.Add("NewCausalityMethodRuleset_2"); //4
		// ruleNames.Add("NewCausalityMethodRuleset_3"); //2
		// ruleNames.Add("INVDMarkerRules"); //6
		// ruleNames.Add("INVDMarkerRules_2"); //0?
		// ruleNames.Add("CalibrationNewRuleset"); //12
		// ruleNames.Add("CalibrationNewRuleset_2"); //0?
		// ruleNames.Add("RFlagCleanRuleset"); //1
		// ruleNames.Add("ICFixTotalRuleset"); //12
		// ruleNames.Add("TransformerFlipRuleset"); //1
		// ruleNames.Add("TransformerFlipRuleset2"); //1
		// ruleNames.Add("Clean23Ruleset"); //4
		// ruleNames.Add("BeforeBG-VerifyDirRuleSet"); //8
		await RuleSetMap.getInstance().loadRuleSet("ADD");
		await RuleSetMap.getInstance().loadRuleSet("CONNECT");
		// await RuleSetMap.getInstance().loadRuleSet("BIG1");
		// foreach (string str in ruleNames)
		// {
		// 	await RuleSetMap.getInstance().loadRuleSet(str);
		// 	loadPercent = Math.Floor((RuleSetMap.getInstance().getNumRules() / totalRules) * 100.0);
		// 	base.StateHasChanged();
		// }

		// // allRulesLoaded = true;
		base.StateHasChanged();
	}

	public void updatePinBindings(ComponentInstance comp)
	{
		var compPins = getPins(comp.gsNode);

		var connArcs = GraphSynthInvoke.GetArcs().Where(a=>a.localLabels.Contains("connection")).ToList();
		//List<arc> connArcs = new();

		foreach (arc a in connArcs)
		{
			ComponentInstance ha = comps[Convert.ToInt32(a.To.localLabels.Find(s => s.StartsWith("localId:")).Substring(8))];
			ComponentInstance hb = comps[Convert.ToInt32(a.From.localLabels.Find(s => s.StartsWith("localId:")).Substring(8))];

			if (ha != comp)
			{
				var temp = ha;
				ha = hb;
				hb = temp;
			}

			int i1 = ComponentDeclarations.components[ha.globalId].pins[a.To.name];
			int i2 = ComponentDeclarations.components[hb.globalId].pins[a.From.name];


			comp.connMap.Add(i1, i2);
		}
	}


	public List<node> getPins(node n){

		return (from a in n.arcs select ((arc)a).otherNode(n)).ToList();

	}

	List<String> inputs = new List<string> {  "arduinouno_rev3","adxl345" };
	// List<String> inputs = new List<string> {  "arduinoUno_rev3","led" };
	public void test()
	{

		GraphSynthInvoke.recg_apply(inputs);
		List<node> b = GraphSynthInvoke.GetNodes();
		List<arc> c = GraphSynthInvoke.GetArcs();

		int numofcon = 0;
		for(int i = 0; i<c.Count; i++)
		{
			if (c[i].localLabels.Contains("connection")){
				numofcon++;
			}
		}
		Console.WriteLine("the number of nodes is " + b.Count);
		Console.WriteLine("the number of connections is " + numofcon);
	
	}
}