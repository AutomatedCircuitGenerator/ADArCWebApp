@page "/"
@using GraphSynth.Representation
@using ADArCWebApp.Shared.UIComponents
@inject IJSRuntime JsRuntime
@inject NavigationManager navMan
@inject BoardService BoardService
@inject ToastService ToastService
@inject GraphSynthInvoke GraphSynthInvoke

<PageTitle>Index</PageTitle>
<head>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.2.0/introjs.min.css" rel="stylesheet"/>
</head>
<body>
<script suppress-error="BL9992" type="module" src="build/build.js"></script>
<button @ref="refresh" hidden="hidden" @onclick="StateChanged">refresh</button>
<BoardSelect OnSelect="HandleBoardSelect"></BoardSelect>
<div class="page" data-title="Welcome to ADArC" data-intro="ADArC stands for Automated Design tool for Arduino Circuits! This is a circuit design tool for building projects with Arduino Microcontrollers.">
    <div class="toolbar" data-title="Toolbar" data-intro="This is the toolbar. This contains tools to modify, research, and run your project">
        <div class="logo-and-adarc">
            <img class="logo" src="images/adarc-logo.001.png" alt="adarc-logo">
            <span class="adarc-text">ADArC</span>
        </div>

        <button class="tutorial-button toolbar-button" style="font-size: 18px" @onclick="RunTutorial">
            <!-- change -->
            💡 Tutorial
        </button>
        <div class="center-toolbar">
            <div class="Import-Export" data-title="Import & Export Buttons" data-intro="These are your Import and Export buttons. These are used to save and upload your current and past projects for future work.">
                <button style="visibility:@(selLockedOut || IsRunning ? "hidden" : "visible")" class="toolbar-button" @onclick="() => _exampleModalOpen=true">
                    Example
                </button>
                <button style="visibility:@(selLockedOut || IsRunning ? "hidden" : "visible")" @onclick="DownloadFile" class="toolbar-button">
                    <span>⬆️ Export</span>
                </button>

                <InputFile id="import-button" accept=".adarc" style="display:none;" OnChange="LoadFromFile"/>
                <label for="import-button" class="toolbar-button" style="visibility:@(selLockedOut || IsRunning ? "hidden" : "visible")">
                    <span>⬇️️ Import</span>
                </label>
            </div>
            <button class="toolbar-button" @onclick="OpenExternalHelp" data-title="Help Buttons" data-intro="This will take you to our dedicated help website, where you can research the datasheets and uses of each of the components we have available.">
                <span>ℹ Help</span>
            </button>
            <button class="toolbar-button" @onclick="ToggleRunStop" data-title="Run/Compile" data-intro="This will compile your code and start simulating your project. This should be run when you are finished designing your project.">
                <span>@runStopText</span>
            </button>
        </div>
    </div>
    <div class="page-content" @onmousedown="CheckForCardDrag" @onmousemove="DragCardIfPossible" @onmouseup="AddToCanvasIfNecessary">
        <div class="main-canvas" tabindex="0" @onkeydown="HandleKeyPress">
            <MainCanvas comps=@(Comps) handleMouseEnter="() => allowDrop = true" handleMouseLeave="() => allowDrop = false"></MainCanvas>
        </div>
        <div class="sidebar" style="width: 25%; left: @(leftPaneAlign + "%")" data-title="Component Palette" data-intro="This is the Component Palette. Here you can choose from our library of components to create your project. All the wires are automatically connected once you add a component to the workbench.">
            <div class="expand-button expand-button-left" @onclick="ToggleLeftSidebar" style="left:100%;">
                @if (isLeftExpanded)
                {
                    <span>▶</span>
                }
                else
                {
                    <span>◀</span>
                }
            </div>
            <ComponentPane host="@this"></ComponentPane>
        </div>
        <div id="mover" style="pointer-events:none; position:absolute; top:@(moverOffsetTop)px; left:@(moverOffsetLeft)px; transform:translate(-50%, -50%); visibility:@isVisible; width:@(ComponentDeclarations.Components[moverId].rightOffset)px; height:@(ComponentDeclarations.Components[moverId].bottomOffset)px;">
            <VaryingComponent disableBorder=true posAbsolute="false" individualData="new(moverId, new(), 0, 0)" objId="@moverId" zoomFactor="1" DragStart="() => { }" DragProgress="() => { }" DragEnd="() => { }"></VaryingComponent>
        </div>
        <div class="sidebar-right" style="width: 40%; right: @(rightPaneAlign + "%")" data-title="Code Pane" data-intro="This is where you can start coding the digital Arduino. It follows the same design as the Arduino IDE and contains sample code for each component on the workbench.">
            <div class="expand-button expand-button-right" @onclick="ToggleRightSidebar" style="right:100%;">
                @if (isRightExpanded)
                {
                    <span>▶</span>
                }
                else
                {
                    <span>◀</span>
                }
            </div>
            <CodePane></CodePane>
        </div>
        <Modal Open="@_exampleModalOpen" OnClose="() => _exampleModalOpen = false">
            <ExampleSelect></ExampleSelect>
        </Modal>
        <ToastQueue></ToastQueue>
    </div>
    @if (showZoomTooltip)
    {
        <div class="zoom-tooltip" style="background: #ece1be">
            <label>Use these buttons to zoom in and out of the Canvas.</label>
            <button @onclick="GotItClicked">Got it!</button>
        </div>
    }

    @if (LoadingProgress == -1)
    {
        <div class="workbench-title">
            <span @onclick="ShowRightClickTooltipFn">💡 Workbench</span>
        </div>
    }
    @if (showRightClickTooltip)
    {
        <div class="right-click-tooltip" style="background: #ece1be">
            <label>This is the Workbench.</label>
            <label style="font-size: 13.5px">Right-click components dragged from the Component Palette for environmental settings, information, and deletion. Each component added auto-generates code in the Code Panel, accessible by clicking the arrow icon on the right side of the screen.</label>
            <button @onclick="HideRightClickTooltip">Got it!</button>
        </div>
    }
    <script src="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.2.0/intro.min.js"></script>


</div>
<div class="progress-container" style="display: @(LoadingProgress < 0 ? "none" : "block"); position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%); width: 400px; height: 60px; padding: 25px; background-color: lightgray; border-radius: 10px;">
    <span style="display: inline-block; width: 100%; text-align: center; color: black; transform: translateY(-13px);">@(Math.Round(LoadingProgress, 0))% component rules loaded</span>
    <div class="progress-bar" style="width: @(LoadingProgress)%; height: 10px; background-color: dodgerblue; border-radius: 13px; transform: translateY(-10px);"></div>
</div>
</body>

@code{
    private Modal modal;
    private bool _exampleModalOpen;
    bool isLeftExpanded = true;
    bool isRightExpanded;

    private bool _scheduleBenchSetup;

    /// <summary>
    /// Percentage of screen that the left pane is pushed to the left.
    /// Default position (0) is fully on screen.
    /// </summary>
    int leftPaneAlign => isLeftExpanded ? 0 : -24;

    /// <summary>
    /// Percentage of screen that the right pane is pushed to the right.
    /// Default position (0) is fully on screen.
    /// </summary>
    int rightPaneAlign => isRightExpanded ? 0 : -39;

    string runStopText = "▶️ Run";
    public bool IsRunning;

    void ToggleLeftSidebar()
    {
        isLeftExpanded = !isLeftExpanded;
        isRightExpanded = false;
        StateHasChanged();
    }

    void ToggleRightSidebar()
    {
        isRightExpanded = !isRightExpanded;
        isLeftExpanded = false;
        StateHasChanged();
    }

    private void HandleBoardSelect(Board board)
    {
        Comps[0] = BoardService.GetComponentInstance();

        if (LoadingProgress == -1)
        {
            SetupBenchFromJsonString(BoardService.GetJson());
            CompPane!.ReleaseLockout();
            selLockedOut = false;
        }
        else
        {
            _scheduleBenchSetup = true;
        }
    }


    /// <summary>
    /// Attempts to compile and run the code.
    /// </summary>
    /// <returns></returns>
    async Task ToggleRunStop()
    {
        if (!IsRunning)
        {
            runStopText = "Compiling...";
            var response = await AppInterop.CompileWrapper();


            if (response.stderr != "")
            {
                CodePane?.UpdateConsoleOutput(response.stderr, false);
                runStopText = "▶️ Run";
                //look for available error messages (format roughly error:linenum:columnnum:message)
                var caps = Regex.Match(response.stderr, ":([0-9]*?:[0-9]*?):").Captures;
                if (caps.Count > 0)
                {
                    string lineSection = caps.First().Value;
                    //cut off the colons at the beginning and end
                    lineSection = lineSection[1..^1];
                    //get the index of the middle colon
                    int mid = lineSection.IndexOf(":", StringComparison.Ordinal);
                    //grab line number only
                    int line = int.Parse(lineSection[0..^(lineSection.Length - mid)]);
                    //grab column number only
                    int column = int.Parse(lineSection[(mid + 1)..^0]);
                    //cut off error: to get message
                    string message = Regex.Match(response.stderr, "error:.*").Captures.First().Value[7..^0];
                    AppInterop.MakeMonacoErrorWrapper(message, line, column);
                }
            }
            else //no errors
            {
                CodePane?.UpdateConsoleOutput(response.stdout, false);
                AppInterop.ClearMonacoErrorsWrapper();
                AppInterop.StartSimWrapper();
                runStopText = "🟥 Stop";
                IsRunning = true;
            }
        }
        else //stop running
        {
            AppInterop.StopWrapper();
            CodePane!.CommitBuffer();
            CodePane!.UpdateConsoleOutput("Stopped.\n", false);
            runStopText = "▶️ Run";
            IsRunning = false;
        }
    }

    void OpenExternalHelp()
    {
        const string url = "https://adarc-help.mech.website/";
        JsRuntime.InvokeVoidAsync("window.open", url, "_blank");
    }


    public Index()
    {
        App = this;
    }

    /// <summary>
    /// Provides avenue for non-component classes to invoke render.
    /// </summary>
    public void StateChanged()
    {
        StateHasChanged();
    }


    /// <summary>
    /// re-render is also triggered on events, so create an event with a triggered click.
    /// generally the same as previous and should be removed if possible.
    /// TODO: remove this function and associated objects (element in this file, mini-script that declares triggerClick in index.html)
    /// </summary>
    /// <returns></returns>
    public async Task TriggerRender()
    {
        await JsRuntime.InvokeAsync<object>("triggerClick", refresh);
    }

    private int localIds;


    /// <summary>
    /// main component storage. provides an arduino by default. The arduino is overwritten when rule loading finishes,
    /// but does not change visually (hopefully)
    /// </summary>
    public static readonly Dictionary<int, ComponentInstance> Comps = new()
    {
        // { 0, new ComponentInstance(1, null, 829, 219) }
    };


    public int SelectedComponent = -1;

    public static Index? App;
    public static MainCanvas? BuildCanvas;
    public static CodePane? CodePane;
    public static ComponentPane? CompPane;
    public const int DefaultScreenWidth = 1920;
    public static double CurrentWidthRatio = 1;
    public const int DefaultScreenHeight = 1080;
    public static double CurrentHeightRatio = 1;

    public static ElementReference? refresh;

    /// <summary>
    /// Does setup for javascript interop on page load.
    /// Defined by Blazor.
    /// </summary>
    /// <param name="firstRender">true if this is specifically the first render, false otherwise</param>
    /// <returns></returns>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Console.WriteLine("Blazor Load Completed!");

            AppInterop.Runtime = JsRuntime;
            AppInterop.JsModule = await AppInterop.GetModuleWrapper();

            AppInterop.UpdateScreenRatios(await AppInterop.GetWindowWidth(), await AppInterop.GetWindowHeight());
            //AppInterop.startSimWrapper();
            //AppInterop.updateCodeWrapper();
        }
    }


    #region component pane integration

    /// <summary>
    /// Dragged component global id. Used to transfer data out of the palette to this file.
    /// </summary>
    private int targetCardComponentId = -1;

    /// <summary>
    /// Controls what component is displayed while the drag is ongoing.
    /// </summary>
    private int moverId => targetCardComponentId == -1 ? 1 : targetCardComponentId;

    private string isVisible = "hidden";
    private bool allowDrop = false;

    private double moverOffsetTop = 0;
    private double moverOffsetLeft = 0;

    public void SetTargetId(int id)
    {
        targetCardComponentId = id;
    }

    //functions to handle component dragged from palette to workbench
    private void CheckForCardDrag(MouseEventArgs e)
    {
        if (e.Button != 0 || targetCardComponentId == -1) return;
        isVisible = "visible";
        moverOffsetLeft = e.ClientX;
        moverOffsetTop = e.ClientY;
    }

    private void DragCardIfPossible(MouseEventArgs e)
    {
        if (targetCardComponentId == -1) return;
        moverOffsetLeft = e.ClientX;
        moverOffsetTop = e.ClientY;
    }

    private void AddToCanvasIfNecessary(MouseEventArgs e)
    {
        if (targetCardComponentId == -1) return;
        isVisible = "hidden";
        if (allowDrop) //ie, cursor is over the workbench
        {
            ++localIds;
            var componentData = ComponentDeclarations.Components[targetCardComponentId];
            var n = new node(); //label with localId (easy tracking)
            n.localLabels.Add("user_" + componentData.nodeName);

            GraphSynthInvoke.GetNodes().Add(n);
            if (componentData.nodeName != null) GraphSynthInvoke.Inputs.Add(componentData.nodeName);

            GraphSynthInvoke.Add();
            if (!GraphSynthInvoke.Connect(componentData.nodeName, "arduino", SelectArduinoNode))
            {
                moverOffsetLeft = 0;
                moverOffsetTop = 0;
                targetCardComponentId = -1;
                GraphSynthInvoke.RemoveConnectedComponent(n);
                return;
            }

            //label all new nodes and connections with the localid of the component that added them.
            GraphSynthInvoke.GetNodes().FindAll(node => node.localLabels.Find(s => s.StartsWith("localId:")) == null).ToList().ForEach(node => node.localLabels.Add("localId:" + localIds));
            GraphSynthInvoke.GetArcs().FindAll(a => a.localLabels.Find(s => s.StartsWith("localId:")) == null).ToList().ForEach(a => a.localLabels.Add("localId:" + localIds));
            //create frontend instance
            var comp = new ComponentInstance(targetCardComponentId, n, e.ClientX - (.5 * componentData.rightOffset), e.ClientY - (.5 * componentData.bottomOffset) - 50);
            comp.localId = localIds;
            Comps.Add(localIds, BuildCanvas?.UnZoom(comp)); //50 is height of toolbar
            BuildCode.outputPins.Clear();
            BuildCanvas!.ConnLines.Clear();
            //reset the way that component pins are bound to the arduino.
            //TODO: check for performance improvements here.
            foreach (var c in Comps.Values)
            {
                UpdatePinBindings(c); //keep an eye on this. could be not good for performance.
            }

            //register the dht specifically to forced the arduino to pause while awaiting response from sensor
            //TODO: improve and generalize.
            if (Comps[localIds].GlobalId == 20)
            {
                //Console.WriteLine("wait for:" + comps[localIds].connMap[1][0].toId);
                AppInterop.RegisterResponseRequired(Comps[localIds].ConnMap[1][0].ToId);
            }

            //create listeners for arduino pins to components.
            //Personally, not a huge fan of this system. good place for improvement
            setupListeners();
            ToastService.AddToast("Code panel updated.", Variant.Info);
        }
        
        moverOffsetLeft = 0;
        moverOffsetTop = 0;
        targetCardComponentId = -1;
    }

    private node? SelectArduinoNode(List<node> nodes, HashSet<string> labels)
    {
        List<node> i2cNodes = [];
        List<node> pwmNodes = [];
        List<node> analogNodes = [];
        List<node> usartNodes = [];
        List<node> spiNodes = [];
        List<node> connectedCandidates = [];
        bool isSpecial = labels.Contains("sda") || labels.Contains("scl") || labels.Contains("rx") ||
                         labels.Contains("tx") || labels.Contains("pwm") || labels.Contains("analog") ||
                         labels.Contains("sck") || labels.Contains("cipo") || labels.Contains("copi");
        bool sharedConnection = labels.Contains("sda") || labels.Contains("scl") || labels.Contains("sck") || labels.Contains("copi") || labels.Contains("cipo");
        foreach (var node in nodes)
        {
            var localLabels = new HashSet<string>(node.localLabels);
            // if this is the case, this is definetly not the node we are looking for.
            if (!labels.IsSubsetOf(localLabels)) continue;
            // this node is correct, but already has a connection. we mark this for error reporting.
            if (localLabels.Contains("connected") || (localLabels.Contains("bus") && !sharedConnection))
            {
                connectedCandidates.Add(node);
                continue;
            }

            // if we are looking for a special node, stop here
            if (isSpecial)
            {
                if (sharedConnection && !localLabels.Contains("bus"))
                {
                    node.localLabels.Add("bus");
                }

                return node;
            }

            // if we are looking for a GPIO pin, try to protect special pins
            if (localLabels.Contains("sda") || localLabels.Contains("scl"))
            {
                i2cNodes.Add(node);
            }
            else if (localLabels.Contains("pwm"))
            {
                pwmNodes.Add(node);
            }
            else if (localLabels.Contains("analog"))
            {
                analogNodes.Add(node);
            }
            else if (localLabels.Contains("tx") || localLabels.Contains("rx"))
            {
                usartNodes.Add(node);
            }
            else if (localLabels.Contains("copi") || localLabels.Contains("cipo") || localLabels.Contains("sck"))
            {
                spiNodes.Add(node);
            }
            else // if we have found a non-reserved node
            {
                return node;
            }
        }

        // Fallback priority: PWM -> USART -> Analog -> SPI -> I2C
        node? selectedNode = null;
        if (pwmNodes.Count > 0)
        {
            selectedNode = pwmNodes.First();
        }
        else if (usartNodes.Count > 0)
        {
            selectedNode = usartNodes.First();
        }
        else if (analogNodes.Count > 0)
        {
            selectedNode = analogNodes.First();
        }
        else if (spiNodes.Count > 0)
        {
            selectedNode = spiNodes.First();
        }
        else if (i2cNodes.Count > 0)
        {
            selectedNode = i2cNodes.First();
        }

        // Return the selected fallback node or null if no match was found
        if (selectedNode != null) return selectedNode;
        List<string> connectedComponentNames = [];
        List<string> connectedPinNames = [];
        List<ComponentInstance> connectedComponents = [];
        foreach (var candidate in connectedCandidates)
        {
            var pinName = "";
            foreach (var label in candidate.localLabels)
            {
                if (Regex.IsMatch(label, @"a\d+"))
                {
                    pinName = label;
                    break;
                }

                if (Regex.IsMatch(label, @"d\d+"))
                {
                    pinName = label;
                }
            }

            var componentPin = candidate.arcsFrom.Find(a => a.localLabels.Contains("connection"))?.To ?? candidate.arcsTo.Find(a => a.localLabels.Contains("connection"))?.From;
            var componentNode = componentPin?.arcsFrom.Find(a => !a.localLabels.Contains("connection"))?.To ?? componentPin?.arcsTo.Find(a => !a.localLabels.Contains("connection"))?.From;
            if (componentNode != null)
            {
                var componentIdLabel = componentNode.localLabels.Find(l => l.Contains("localId:"));
                if (componentIdLabel != null)
                {
                    var connectedComponentId = int.Parse(componentIdLabel[8..]);
                    connectedPinNames.Add(pinName);
                    connectedComponentNames.Add(componentNode.localLabels.First());
                    connectedComponents.Add(Comps[connectedComponentId]);
                }
            }
        }

        var message = "No more pins are available. Try removing ";
        for (int i = 0; i < Math.Min(3, connectedComponentNames.Count); i++)
        {
            if (i == Math.Min(3, connectedComponentNames.Count) - 2)
            {
                message += $"{connectedComponentNames[i]} on pin {connectedPinNames[i]} or ";
            }
            else if (i < Math.Min(3, connectedComponentNames.Count) - 1)
            {
                message += $"{connectedComponentNames[i]} on pin {connectedPinNames[i]}, ";
            }
            else
            {
                message += $"{connectedComponentNames[i]} on pin {connectedPinNames[i]}.";
            }
        }

        ToastService.AddToast(message, Variant.Error, connectedComponents.Take(3));
        return selectedNode;
    }

    /// <summary>
    /// Binds component translation functions to arduino pins through listeners.
    /// </summary>
    private void setupListeners()
    {
        if (!Comps.Values.Any(c => c.IsArduino())) return; //set has an arduino uno

        foreach (var c in Comps.Values) //iterate all components (don't know what listeners exist already)
        {
            if (c.IsArduino()) continue; //exclude the arduino
            foreach (var listen in c.Data.pinsToListen) //add a listener for each important pin
            {
                var pin = -1;
                if (0 == c.GetConnection(listen, out InstanceConnection? conn, out List<InstanceConnection>? all))
                {
                    pin = conn!.ToId;
                }

                bool hasList = AvrCPU.pinListeners.TryGetValue(pin, out var list);
                //hopefully the only time the list extends
                //is on arduino, which is excluded here
                if (hasList && list!.Any(el => el.actor == c)) continue; //no list for this pin yet, or the list does not contain any connections for this component
                var pin2 = -1;
                if (0 == c.GetConnection(listen, out InstanceConnection? conn2, out List<InstanceConnection>? all2))
                {
                    pin2 = conn2!.ToId;
                }

                //TODO: fix so that all componenents inherit from one class
                var info = c.Data.compType.GetMethod("translate");
                if (info != null)
                {
                    AvrCPU.addListener(pin2, c, info);
                }
                else
                {
                    Console.WriteLine("Attempted to listen on component without translation! this is probably an error!");
                }
            }
        }

        AppInterop.UpdateCodeWrapper();
    }

    #endregion

    private readonly List<string> ruleNames = new();

    /// <summary>
    /// Disables the palette until rules are loaded.
    /// </summary>
    private bool selLockedOut = true;

    /// <summary>
    /// This is triggered exactly once when blazor is loaded, but before render if I remember correctly.
    /// In general, order is html load -> this -> render
    /// </summary>
    /// <returns></returns>
    protected override async Task OnInitializedAsync()
    {
        //TODO: find a way to automatically update the max number of rules so bar won't go over 100%.
        // ^^ Hard to do because it downloads the rule set inside of the function, yet needs knowledge of next ruleset which hasnt been downloaded
        // can request just one file?
        int x = await RuleSetMap.GetInstance().LoadRuleSet("ADD", navMan, this, 0, 58);
        await RuleSetMap.GetInstance().LoadRuleSet("CONNECT", navMan, this, x, 58);
        GraphSynthInvoke.rulesets = RuleSetMap.Rulesets;
        if (_scheduleBenchSetup)
        {
            SetupBenchFromJsonString(BoardService.GetJson());
            CompPane!.ReleaseLockout();
            selLockedOut = false;
        }

        //all else finish first
        await Task.Delay(1000);
        LoadingProgress = -1;

        // await RuleSetMap.getInstance().loadRuleSet("BIG1");
        // foreach (string str in ruleNames)
        // {
        // 	await RuleSetMap.getInstance().loadRuleSet(str);
        // 	loadPercent = Math.Floor((RuleSetMap.getInstance().getNumRules() / totalRules) * 100.0);
        // 	base.StateHasChanged();
        // }

        // // allRulesLoaded = true;
    }

    /// <summary>
    /// sets up a components pin bindings to an arduino.
    /// TODO: improve this function or find a way to remove it entirely.
    /// </summary>
    /// <param name="comp">A component instance to update the bindings on.</param>
    private void UpdatePinBindings(ComponentInstance comp)
    {
        comp.ConnMap.Clear();
        //buildCanvas!.connLines.Clear();

        var compPins = GetPins(comp.GsNode, comp.Data.nodeName);
        if (compPins.Count == 0)
        {
            return;
        }

        var connArcs = GraphSynthInvoke.GetArcs().Where(a => a.localLabels.Contains("connection")).ToList();
        //List<arc> connArcs = new();

        foreach (arc a in connArcs)
        {
            ComponentInstance ha = Comps[Convert.ToInt32(a.To.localLabels.Find(s => s.StartsWith("localId:")).Substring(8))];
            ComponentInstance hb = Comps[Convert.ToInt32(a.From.localLabels.Find(s => s.StartsWith("localId:")).Substring(8))];


            if (ha == hb)
            {
                continue;
            }

            if (ha != comp && hb != comp)
            {
                continue;
            }

            if (ha != comp)
            {
                (ha, hb) = (hb, ha);
            }

            var aPinName = "**NF**";

            if ((ha.IsArduino() && (a.To.localLabels.Contains("localId:1") || a.To.localLabels.Contains("localId:2"))) || (!ha.IsArduino() && !(a.To.localLabels.Contains("localId:1") || a.To.localLabels.Contains("localId:2"))))
            {
                aPinName = (from df in ha.Data.pins.Keys where a.To.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
            }

            string bPinName = "";


            if (aPinName == "**NF**")
            {
                aPinName = (from df in ha.Data.pins.Keys where a.From.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
                bPinName = (from df in hb.Data.pins.Keys where a.To.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
            }
            else
            {
                bPinName = (from df in hb.Data.pins.Keys where a.From.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
            }

            //if arduino and data pin being connected, register to code.
            if ((ha.IsArduino()) && System.Text.RegularExpressions.Regex.Match(aPinName, "d[0-9]{1,2}").Success)
            {
                BuildCode.outputPins.Add(Convert.ToInt32(aPinName.Substring(1)));
                //Console.WriteLine("1: " + BuildCode.outputPins.Count);
            }

            if (aPinName == "**NF**")
            {
                Console.WriteLine(ha.Data.name + " is missing a pin definition!");
            }

            if (bPinName == "**NF**")
            {
                Console.WriteLine(hb.Data.name + " is missing a pin definition!");
            }

            int i1 = ha.Data.pins[aPinName];
            int i2 = hb.Data.pins[bPinName];


            comp.AddConnection(i1, hb, i2, a); //also sets up the drawn line
        }
    }

    /// <summary>
    /// Helper for updatePinBindings to get all pins of a component as graphsynth nodes.
    /// </summary>
    /// <param name="n">The node to get the pins of. Specifically, the root node, not the main node.</param>
    /// <param name="name">The name of the root node, excluding "user_".</param>
    /// <returns></returns>
    private static List<node> GetPins(node n, string name)
    {
        //n is root, connected to main node but not main node.
        var fullName = "user_" + name;
        if (n.arcs.Count == 0)
        {
            return [];
        }

        var mainNode = ((arc)n.arcs[0]).otherNode(n);
        //traverse arcs to get pin nodes, except the root node
        var potential = mainNode.arcs.Select(a => ((arc)a).otherNode(mainNode)).ToList();
        return potential.Where(node => !node.localLabels.Contains(fullName)).ToList();
    }

    /// <summary>
    /// Deletes a component.
    /// </summary>
    public void RemoveComp()
    {
        node Comp2remove = Index.Comps[SelectedComponent].GsNode;

        //specifically deregisters the dht pins from requiring a pause on the arduino.
        //TODO: improve and generalize.
        if (Comps[SelectedComponent].GlobalId == 20)
        {
            AppInterop.UnregisterResponseRequired(Comps[SelectedComponent].ConnMap[1][0].ToId);
        }

        GraphSynthInvoke.RemoveComp(Comp2remove);
        Comps.Remove(SelectedComponent);
        List<node> b = GraphSynthInvoke.GetNodes();
        List<arc> c = GraphSynthInvoke.GetArcs();


        BuildCode.outputPins.Clear();
        BuildCanvas!.ConnLines.Clear();
        foreach (var comp in Comps.Values)
        {
            UpdatePinBindings(comp); //keep an eye on this. could be not good for performance.
        }
        
        ToastService.AddToast("Code panel updated.", Variant.Info);
        
        
        AppInterop.UpdateCodeWrapper();
        /*int numofcon = 0;
        for (int i = 0; i < c.Count; i++)
            {
            if (c[i].localLabels.Contains("connection"))
                {
                numofcon++;
        }
        }
        Console.WriteLine("the number of nodes is " + b.Count);
        Console.WriteLine("the number of connections is " + numofcon);*/
    }

    /// <summary>
    /// Deletes a component when delete/backspace pressed.
    /// </summary>
    /// <param name="e"></param>
    private void HandleKeyPress(KeyboardEventArgs e)
    {
        // 1 is the arduino, not sure what -2 or -1 is
        if (IsRunning || (e.Key is not ("Backspace" or "Delete")) || SelectedComponent == -2 || SelectedComponent == -1 || SelectedComponent == 1) return;
        RemoveComp();
        SelectedComponent = -1;
    }

    //progress bar
    public double LoadingProgress;

    //unused
    private void HandleZoom(string action)
    {
        const double zoomStep = 0.1;

        if (action == "in")
        {
            BuildCanvas!.zoomFactor -= zoomStep;
        }
        else if (action == "out")
        {
            BuildCanvas!.zoomFactor += zoomStep;
        }

        BuildCanvas!.zoomFactor = Math.Clamp(BuildCanvas!.zoomFactor, .4, 3);

        StateHasChanged();
    }

    bool showZoomTooltip = false;
    bool labelShownBefore = false;

    void ShowLabel()
    {
        if (!labelShownBefore)
        {
            showZoomTooltip = true;
        }
    }

    void HideLabel()
    {
        showZoomTooltip = false;
    }

    void GotItClicked() //for zoom tooltip
    {
        labelShownBefore = true;
        showZoomTooltip = false;
    }

    bool showRightClickTooltip = false;

    void HideRightClickTooltip()
    {
        showRightClickTooltip = false;
    }

    void ShowRightClickTooltipFn()
    {
        showRightClickTooltip = true;
    }


    /// <summary>
    /// When a file is imported, handle it.
    /// </summary>
    /// <param name="e"></param>
    /// <returns></returns>
    public async Task LoadFromFile(InputFileChangeEventArgs e)
    {
        var file = e.File;
        var buffer = new byte[file.Size];
        await e.File.OpenReadStream().ReadAsync(buffer);
        var str = System.Text.Encoding.UTF8.GetString(buffer);
        SetupBenchFromJsonString(str);
    }

    /// <summary>
    /// Handles most of the setup process of the bench after import.
    /// </summary>
    /// <param name="json">The full JSON to deserialize.</param>
    public void SetupBenchFromJsonString(string json)
    {
        Console.WriteLine("Starting bench setup from JSON");
        Data? data;
        try
        {
            var options = new JsonSerializerOptions { 
                IncludeFields = true,
                WriteIndented = true
            };
            options.Converters.Add(new ParamSerializer());
            data = JsonSerializer.Deserialize<Data>(json, options);
            
            if (data == null)
            {
                Console.WriteLine("Deserialization returned null");
                return;
            }
            Console.WriteLine($"Deserialization successful. Component count: {data.Comps?.Count ?? 0}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during deserialization: {ex.Message}");
            Console.WriteLine($"JSON content: {json.Substring(0, Math.Min(200, json.Length))}...");
            return;
        }
    
        try
        {
            // Clear existing components
            foreach (var comp in Comps)
            {
                Console.WriteLine($"Removing component {comp.Key}");
                SelectedComponent = comp.Key;
                RemoveComp();
                SelectedComponent = -1;
            }
    
            BuildCanvas!.ConnLines.Clear();
            BuildCanvas.ResetTransform();
            GraphSynthInvoke.Inputs.Clear();
            GraphSynthInvoke.DestroyGraph();
            BuildCode.outputPins.Clear();
            localIds = data.LocalId;
    
            // First pass: Create all component nodes
            foreach (var kv in data.Comps)
            {
                Console.WriteLine($"Setting up component {kv.Key} of type {kv.Value.Data.nodeName}");
                Comps.Add(kv.Key, kv.Value);
                var n = new node();
                n.localLabels.Add("user_" + kv.Value.Data.nodeName);
                kv.Value.GsNode = n;
                
                GraphSynthInvoke.GetNodes().Add(n);
                if (kv.Value.Data.nodeName != null)
                {
                    GraphSynthInvoke.Inputs.Add(kv.Value.Data.nodeName);
                    Console.WriteLine($"Added input for {kv.Value.Data.nodeName}");
                }
    
                // Add and connect each component
                GraphSynthInvoke.Add();
                if (kv.Value.Data.nodeName != null && !kv.Value.IsArduino())
                {
                    var connected = GraphSynthInvoke.Connect(kv.Value.Data.nodeName, "arduino", SelectArduinoNode);
                    Console.WriteLine($"Connected component {kv.Key}: {connected}");
                }
    
                // Label nodes and arcs with localId
                var newNodes = GraphSynthInvoke.GetNodes()
                    .FindAll(node => node.localLabels.Find(s => s.StartsWith("localId:")) == null);
                var newArcs = GraphSynthInvoke.GetArcs()
                    .FindAll(a => a.localLabels.Find(s => s.StartsWith("localId:")) == null);
                    
                foreach(var node in newNodes)
                {
                    node.localLabels.Add("localId:" + kv.Key);
                }
                foreach(var arc in newArcs)
                {
                    arc.localLabels.Add("localId:" + kv.Key);
                }
                
                Console.WriteLine($"Labeled {newNodes.Count} nodes and {newArcs.Count} arcs for component {kv.Key}");
            }
    
            // Second pass: Update bindings and setup listeners
            foreach (var comp in Comps.Values)
            {
                UpdatePinBindings(comp);
                
                // Re-register DHT if present
                if (comp.GlobalId == 20)
                {
                    if (comp.ConnMap.ContainsKey(1) && comp.ConnMap[1].Count > 0)
                    {
                        AppInterop.RegisterResponseRequired(comp.ConnMap[1][0].ToId);
                        Console.WriteLine("Registered DHT component");
                    }
                }
            }
    
            Console.WriteLine("Setting up listeners");
            setupListeners();
            Console.WriteLine("Setting code");
            AppInterop.SetCodeWrapper(data.Code);
            Console.WriteLine("Bench setup complete");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during bench setup: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            throw;
        }
    }

    /// <summary>
    /// Create file data and send it off to JS for downloading.
    /// </summary>
    public async void DownloadFile()
    {
        var stream = new MemoryStream();
        var writer = new StreamWriter(stream);
        await writer.WriteAsync(await ExportJson());
        await writer.FlushAsync();
        stream.Position = 0;

        using var streamRef = new DotNetStreamReference(stream: stream, leaveOpen: true);

        AppInterop.DownloadFile("adarc-circuit.adarc", streamRef);
    }


    class Data
    {
        // public List<InstanceConnection> ConnLines { get; set; }
        public int LocalId { get; set; }
        public string Code { get; set; }
        public Dictionary<int, ComponentInstance> Comps { get; set; }
    }

    /// <summary>
    /// Creates a JSON string representing most of the current state of the circuit.
    /// </summary>
    /// <returns>A JSON string of a Data object.</returns>
    private async Task<string> ExportJson()
    {
        Data parentObject = new Data
        {
            // ConnLines = Index.buildCanvas.connLines,
            Comps = Comps,
            LocalId = localIds,
            Code = await AppInterop.GetCodeWrapper()
        };

        var options = new JsonSerializerOptions { IncludeFields = true };
        options.Converters.Add(new ParamSerializer());
        return JsonSerializer.Serialize(parentObject, options);
    }

    /// <summary>
    /// Deserializes a JSON string to Data object.
    /// </summary>
    /// <param name="jsonString">The JSON to deserialize.</param>
    /// <returns>A Data object.</returns>
    private static Data? DeserializeJson(string jsonString)
    {
        try
        {
            // Deserialize JSON data into a Data object
            var options = new JsonSerializerOptions { IncludeFields = true };
            options.Converters.Add(new ParamSerializer());
            Data? canvasData = JsonSerializer.Deserialize<Data>(jsonString, options) ?? throw new InvalidOperationException("Deserialization failed: 'canvasData' is null. Check if 'jsonString' is in the correct format.");

            // Now you have access to the deserialized data as a CanvasData object
            // Do whatever you need with this data

            return canvasData;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during deserialization: {ex.Message}");
        }

        return null;
    }

    // runs the introjs tutorial
    public async void RunTutorial()
    {
        // var module = await JS.InvokeAsync<IJSObjectReference>("window.backendManager.getBackendManager");
        // ant-menu-submenu-hidden
        await AppInterop.JsModule!.InvokeVoidAsync("runTutorial");
        //await AppInterop.jsModule!.InvokeVoidAsync("runTutorial", true);
        StateHasChanged();
    }

}