@page "/"
@using GraphSynth.Representation
@using System.Text.Json
@inject IJSRuntime JsRuntime
@inject NavigationManager navMan

<PageTitle>Index</PageTitle>
<head>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.2.0/introjs.min.css" rel="stylesheet" />
</head>
<body>
	<script suppress-error="BL9992" type="module" src="build/build.js"></script>
	<button @ref="refresh" hidden="hidden" @onclick="StateChanged">refresh</button>
	<div class="page" data-title="Welcome Screen" data-intro="Welcome to ADArC!">
		<div class="toolbar" data-title="Toolbar" data-intro="This is the your toolbar. This contains tools to modify, research, and run your project">
		<div class="logo-and-adarc">
			<img class="logo" src="images/adarc-logo.001.png" alt="adarc-logo">
            		<span class="adarc-text">ADArC</span>
		</div>
		<div class="zoom-bar-container" data-title="Zoom" data-intro="These are the Zoom Buttons. This will help you change the scale of your project">
			<button class="zoom-button" @onclick='() => HandleZoom("in")' style="font-size: 12px;">🔎</button>
			<button class="zoom-button" @onclick='() => HandleZoom("out")' style="font-size: 21px;">🔎</button>
		</div>
		@* <div class="Import-Export" data-title="Import & Export Buttons" data-intro="These are your Import and Export buttons. These are used to save and upload your current and past projects for future work.">
			<InputFile id="import-button" accept=".adarc" style="display:none;" OnChange="loadFromFile"/>
			<label for="import-button" class="toolbar-button" style="visibility:@(selLockedOut||isRunning?"hidden":"visible")">
				⬇️️ Import
			</label>

			<button style="visibility:@(selLockedOut||isRunning?"hidden":"visible")" @onclick="downloadFile" class="toolbar-button">
				<span>⬆️ Export</span>
			</button>
		</div> *@
		<div class="center-toolbar">
				<div class="Import-Export" data-title="Import & Export Buttons" data-intro="These are your Import and Export buttons. These are used to save and upload your current and past projects for future work.">
					<InputFile id="import-button" accept=".adarc" style="display:none;" OnChange="loadFromFile" />
					<label for="import-button" class="toolbar-button" style="visibility:@(selLockedOut||isRunning?"hidden":"visible")">
						<span>⬇️️ Import</span>
					</label>

					<button style="visibility:@(selLockedOut||isRunning?"hidden":"visible")" @onclick="downloadFile" class="toolbar-button">
						<span>⬆️ Export</span>
					</button>
				</div>
			<button class="toolbar-button" @onclick="OpenExternalHelp" data-title="Help Buttons" data-intro="This will take you to our dedicated help website, where you can research the datasheets and uses of each of the components we have available.">
				<span>❓Help</span>
			</button>
				<button class="toolbar-button" @onclick="ToggleRunStop" data-title="Run/Compile" data-intro="This will compile your code and start simulating your project. This should be run when you are finished designing your project.">
				<span>@runStopText</span>
			</button>
		</div>
	</div>
		

		<div class="page-content" @onmousedown="checkForCardDrag" @onmousemove="dragCardIfPossible" @onmouseup="addToCanvasIfNecessary">
			<div class="main-canvas" tabindex="0" @onkeydown="handleKeyPress">
				<MainCanvas comps=@(comps) handleMouseEnter="()=>allowDrop=true" handleMouseLeave="()=>allowDrop=false"></MainCanvas>
			</div>
			<div class="sidebar" style="width: 25%; left: @(leftPaneAlign+"%")" data-title="Component Pane" data-intro="This is the Component Pane. Here you can choose from our library of components to create your project. All the wires are automatically connected once you add a component to the workbench.">
				<div class="expand-button expand-button-left" @onclick="ToggleLeftSidebar" style="left:100%;">
					<span>◀</span>
				</div>
				<ComponentPane host="@this"></ComponentPane>
			</div>
			<div id="mover" style="pointer-events:none; position:absolute; top:@(moverOffsetTop)px; left:@(moverOffsetLeft)px; transform:translate(-50%, -50%); visibility:@isVisible; width:@(ComponentDeclarations.components[moverID].rightOffset)px; height:@(ComponentDeclarations.components[moverID].bottomOffset)px;">
				<VaryingComponent disableBorder=true posAbolute="false" individualData="new(moverID, new(), 0, 0)" objId="@moverID" zoomFactor="buildCanvas?.zoomFactor == null? 1: buildCanvas.zoomFactor" DragStart="()=>{}" DragProgress="()=>{}" DragEnd="()=>{}"></VaryingComponent>
			</div>
			<div class="sidebar-right" style="width: 40%; right: @(rightPaneAlign+"%")" data-title="Code Pane" data-intro="This is where you can start coding the digital Arduino. It follows the same design as the Arduino IDE and contains sample code for each component on the workbench.">
				<div class="expand-button expand-button-right" @onclick="ToggleRightSidebar" style="right:100%;">
					<span>◀</span>
				</div>
				<CodePane></CodePane>
			</div>
		</div>
	</div>
<div class="progress-container" style="display: @(loadingProgress < 0 ? "none" : "block"); position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%); width: 400px; height: 60px; padding: 25px; background-color: lightgray; border-radius: 10px;">
			<span style="display: inline-block; width: 100%; text-align: center; color: black; transform: translateY(-13px);">@(Math.Round(loadingProgress, 0))% component rules loaded</span>
			<div class="progress-bar" style="width: @(loadingProgress)%; height: 10px; background-color: dodgerblue; border-radius: 13px; transform: translateY(-10px);"></div>
		</div>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.2.0/intro.min.js"></script>
	<script>
		introJs().start();
	</script>

</body>


@code{
	bool isLeftExpanded = true;
	bool isRightExpanded = false;
	int leftPaneAlign => isLeftExpanded ? 0 : -23;
	int rightPaneAlign => isRightExpanded ? 0 : -37;
	string runStopText = "▶ Run";
	public bool isRunning = false;

	void ToggleLeftSidebar()
	{
		isLeftExpanded = !isLeftExpanded;
		isRightExpanded = false;
	}

	void ToggleRightSidebar()
	{
		isRightExpanded = !isRightExpanded;
		isLeftExpanded = false;
	}
	async Task ToggleRunStop()
	{
		if (!isRunning)
		{
			runStopText = "Compiling...";
			var response = await AppInterop.compileWrapper();


			if (response.stderr != "")
			{
				codePane.updateConsoleOutput(response.stderr, false);
				runStopText = "▶ Run";
				var caps = Regex.Match(response.stderr, ":([0-9]*?:[0-9]*?):").Captures;
				if (caps.Count > 0)
				{
					string lineSection = caps.First().Value;
					lineSection = lineSection[1..^1];
					int mid = lineSection.IndexOf(":");
					int line = int.Parse(lineSection[0..^(lineSection.Length - mid)]);
					int column = int.Parse(lineSection[(mid + 1)..^0]);

					string message = Regex.Match(response.stderr, "error:.*").Captures.First().Value[7..^0];
					AppInterop.makeMonacoErrorWrapper(message, line, column);
				}

			}
			else
			{
				codePane.updateConsoleOutput(response.stdout, false);
				AppInterop.clearMonacoErrorsWrapper();
				AppInterop.startSimWrapper();
				runStopText = "🟥 Stop";
				isRunning = true;
			}
		}
		else
		{
			AppInterop.stopWrapper();
			codePane!.newLineIfNot();
			codePane!.updateConsoleOutput("Stopped.\n", false);
			runStopText = "▶ Run";
			isRunning = false;
		}
	}

	void OpenExternalHelp()
	{
		string url = "https://adarc-help.mech.website/";
		JsRuntime.InvokeVoidAsync("window.open", url, "_blank");	
	}




	public Index()
	{
		app = this;
	}

	public void StateChanged()
	{
		StateHasChanged();
	}

	public async Task triggerRender()
	{
		await JsRuntime.InvokeAsync<object>("triggerClick", refresh);
	}

	private int localIds = 0;

	public static Dictionary<int, ComponentInstance> comps = new()
	{
	};


	public int selectedComponent = -1;

	public static Index? app;
	public static MainCanvas? buildCanvas;
	public static CodePane? codePane;
	public static ComponentPane? compPane;
	public static readonly int defaultScreenWidth = 1920;
	public static double currentWidthRatio = 1;
	public static readonly int defaultScreenHeight = 1080;
	public static double currentHeightRatio = 1;

	public static ElementReference? refresh;



	protected async override Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			Console.WriteLine("Blazor Load Completed!");

			AppInterop.runtime = JsRuntime;
			AppInterop.jsModule = await AppInterop.getModuleWrapper();

			AppInterop.updateScreenRatios(await AppInterop.getWindowWidth(), await AppInterop.getWindowHeight());
			await AppInterop.jsModule!.InvokeAsync<object>("runTutorial");
			//AppInterop.startSimWrapper();
			//AppInterop.updateCodeWrapper();
		}
	}



	#region component pane integration
	private int targetCardComponentId = -1;
	private int moverID => targetCardComponentId == -1 ? 1 : targetCardComponentId;
	private string isVisible = "hidden";
	private bool allowDrop = false;

	private double moverOffsetTop = 0;
	private double moverOffsetLeft = 0;

	public void setTargetID(int id)
	{
		targetCardComponentId = id;
	}


	private void checkForCardDrag(MouseEventArgs e)
	{
		if (e.Button == 0 && targetCardComponentId != -1)
		{
			isVisible = "visible";
			moverOffsetLeft = e.ClientX;
			moverOffsetTop = e.ClientY;
		}
	}

	private void dragCardIfPossible(MouseEventArgs e)
	{
		if (targetCardComponentId != -1)
		{
			moverOffsetLeft = e.ClientX;
			moverOffsetTop = e.ClientY;
		}
	}

	public void addToCanvasIfNecessary(MouseEventArgs e)
	{
		if (targetCardComponentId != -1)
		{
			isVisible = "hidden";
			if (allowDrop)
			{
				++localIds;
				var d = ComponentDeclarations.components[targetCardComponentId];
				var n = new node();//label with localId (easy tracking)
				n.localLabels.Add("user_" + d.nodeName);

				GraphSynthInvoke.GetNodes().Add(n);
				GraphSynthInvoke.inputs.Add(d.nodeName);
				GraphSynthInvoke.recg_apply();

				GraphSynthInvoke.GetNodes().FindAll(n => n.localLabels.Find(s => s.StartsWith("localId:")) == null).ToList().ForEach(n => n.localLabels.Add("localId:" + localIds));
				GraphSynthInvoke.GetArcs().FindAll(a => a.localLabels.Find(s => s.StartsWith("localId:")) == null).ToList().ForEach(a => a.localLabels.Add("localId:" + localIds));
				comps.Add(localIds, buildCanvas.unZoom(new ComponentInstance(targetCardComponentId, n, e.ClientX - (.5*d.rightOffset), e.ClientY - (.5*d.bottomOffset)-50)));//50 is height of toolbar
				BuildCode.outputPins.Clear();
				buildCanvas!.connLines.Clear();
				foreach (var c in comps.Values)
				{
					updatePinBindings(c);	//keep an eye on this. could be not good for performance.
				}

				if (comps[localIds].globalId == 20)
				{
					//Console.WriteLine("wait for:" + comps[localIds].connMap[1][0].toId);
					AppInterop.registerResponseRequired(comps[localIds].connMap[1][0].toId);
				}
				setupListeners();

			}
			moverOffsetLeft = 0;
			moverOffsetTop = 0;
			targetCardComponentId = -1;
		}
	}


	private void setupListeners()
	{
		if (comps.Values.Any(c => c.globalId == 1)) //set has an arduino uno
		{
			foreach (var c in comps.Values)     //iterate all components (don't know what listeners exist already)
			{
				if (c.globalId != 1)            //exclude the arduino
				{
					foreach (string listen in c.data.pinsToListen)  //add a listener for each important pin
					{
						int pin = -1;
						if (0 == c.getConnection(listen, out InstanceConnection? conn, out List<InstanceConnection>? all))
						{
							pin = conn!.toId;
						}

						bool hasList = AvrCPU.pinListeners.TryGetValue(pin, out var list);
						//hopefully the only time the list extends
						//is on arduino, which is excluded here
						if (!hasList || !list!.Any(el => el.actor == c))            //no list for this pin yet, or the list does not contain any connections for this component
						{
							int pin2 = -1;
							if (0 == c.getConnection(listen, out InstanceConnection? conn2, out List<InstanceConnection>? all2))
							{
								pin2 = conn2!.toId;
							}
							var info = c.data.compType.GetMethod("translate");
							if (info != null)
							{
								AvrCPU.addListener(pin2, c, info);
							}
							else
							{
								Console.WriteLine("Attempted to listen on component without translation! this is probably an error!");
							}
						}
					}
				}
			}

			AppInterop.updateCodeWrapper();
		}
	}

	#endregion

	private readonly List<string> ruleNames = new();
	private readonly double totalRules = 19.0;
	private string fileToLoad = "";
	private double loadPercent = 0;
	private bool selLockedOut = true;

	protected override async Task OnInitializedAsync()
	{

		// loads rulesets
		// allRulesLoaded = false;
		// ruleNames.Add("BondGraphRuleset"); //58
		// ruleNames.Add("SimplificationRuleset"); //28
		// ruleNames.Add("DirRuleset"); //5
		// ruleNames.Add("newDirectionRuleSet_2"); //17
		// ruleNames.Add("DirRuleset3"); //4
		// ruleNames.Add("Simplification2"); //32
		// ruleNames.Add("NewCausalityMethodRuleset"); //6
		// ruleNames.Add("NewCausalityMethodRuleset_2"); //4
		// ruleNames.Add("NewCausalityMethodRuleset_3"); //2
		// ruleNames.Add("INVDMarkerRules"); //6
		// ruleNames.Add("INVDMarkerRules_2"); //0?
		// ruleNames.Add("CalibrationNewRuleset"); //12
		// ruleNames.Add("CalibrationNewRuleset_2"); //0?
		// ruleNames.Add("RFlagCleanRuleset"); //1
		// ruleNames.Add("ICFixTotalRuleset"); //12
		// ruleNames.Add("TransformerFlipRuleset"); //1
		// ruleNames.Add("TransformerFlipRuleset2"); //1
		// ruleNames.Add("Clean23Ruleset"); //4
		// ruleNames.Add("BeforeBG-VerifyDirRuleSet"); //8
		int x = await RuleSetMap.getInstance().loadRuleSet("ADD", navMan, this, 0,85);
		await RuleSetMap.getInstance().loadRuleSet("CONNECT", navMan, this, x,85);
		compPane!.releaseLockout();
		selLockedOut = false;

		base.StateHasChanged();


		//all else finish first
		await Task.Delay(1000);
		loadingProgress = -1;

		// await RuleSetMap.getInstance().loadRuleSet("BIG1");
		// foreach (string str in ruleNames)
		// {
		// 	await RuleSetMap.getInstance().loadRuleSet(str);
		// 	loadPercent = Math.Floor((RuleSetMap.getInstance().getNumRules() / totalRules) * 100.0);
		// 	base.StateHasChanged();
		// }

		// // allRulesLoaded = true;



	}

	public void updatePinBindings(ComponentInstance comp)
	{
		comp.connMap.Clear();
		//buildCanvas!.connLines.Clear();

		var compPins = getPins(comp.gsNode, comp.data.nodeName);
		if (compPins.Count == 0)
		{
			return;	
		}

		var connArcs = GraphSynthInvoke.GetArcs().Where(a=>a.localLabels.Contains("connection")).ToList();
		//List<arc> connArcs = new();

		foreach (arc a in connArcs)
		{
			ComponentInstance ha = comps[Convert.ToInt32(a.To.localLabels.Find(s => s.StartsWith("localId:")).Substring(8))];
			ComponentInstance hb = comps[Convert.ToInt32(a.From.localLabels.Find(s => s.StartsWith("localId:")).Substring(8))];


			if (ha == hb)
			{
				continue;
			}

			if (ha != comp && hb != comp)
			{
				continue;	
			}
			else if (ha != comp)
			{
				var temp = ha;
				ha = hb;
				hb = temp;
			}

			var aPinName = "**NF**";
			//TODO: del/readd err here !!
			if ((ha.globalId == 1 && a.To.localLabels.Contains("localId:1")) || (ha.globalId != 1 && !a.To.localLabels.Contains("localId:1")))
			{
				aPinName = (from df in ha.data.pins.Keys where a.To.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
			}
			string bPinName = "";


			if (aPinName == "**NF**")
			{
				aPinName = (from df in ha.data.pins.Keys where a.From.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
				bPinName = (from df in hb.data.pins.Keys where a.To.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
			}
			else
			{
				bPinName = (from df in hb.data.pins.Keys where a.From.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
			}

			//if arduino and data pin being connected, register to code.
			if ((ha.globalId == 1) && System.Text.RegularExpressions.Regex.Match(aPinName, "d[0-9]{1,2}").Success)
			{
				BuildCode.outputPins.Add(Convert.ToInt32(aPinName.Substring(1)));
				//Console.WriteLine("1: " + BuildCode.outputPins.Count);
			}

			if (aPinName == "**NF**")
			{
				Console.WriteLine(ha.data.name + " is missing a pin definition!");
			}
			if (bPinName == "**NF**")
			{
				Console.WriteLine(hb.data.name + " is missing a pin definition!");
			}
			int i1 = ha.data.pins[aPinName];
			int i2 = hb.data.pins[bPinName];


			comp.addConnection(i1, hb, i2, a);	//also sets up the drawn line
		}
	}


	public List<node> getPins(node n, string name){
		//n is root, connected to main node but not main node.
		string fullName = "user_" + name;
		if (n.arcs.Count == 0)
		{
			return new();
		}
		var mainNode = ((arc)n.arcs[0]).otherNode(n);
		//traverse arcs to get pin nodes, except the root node
		var potential = mainNode.arcs.Select(a => ((arc)a).otherNode(mainNode)).ToList();
		return potential.Where(n => !n.localLabels.Contains(fullName)).ToList();


	}

	//List<String> inputs = new List<string> {  "arduinouno_rev3","adxl345" };
	// List<String> inputs = new List<string> {  "arduinoUno_rev3","led" };

	//    public void addcomp()
	//    {


	//        GraphSynthInvoke.recg_apply();
	// 	List<node> b = GraphSynthInvoke.GetNodes();
	// 	List<arc> c = GraphSynthInvoke.GetArcs();

	// 	int numofcon = 0;
	// 	for(int i = 0; i<c.Count; i++)
	// 	{
	// 		if (c[i].localLabels.Contains("connection")){
	// 			numofcon++;
	// 		}
	// 	}
	// 	Console.WriteLine("the number of nodes is " + b.Count);
	// 	Console.WriteLine("the number of connections is " + numofcon);
	// }

	public void removecomp()
	{
		node Comp2remove = Index.comps[selectedComponent].gsNode;

		if (comps[selectedComponent].globalId == 20)
		{
			AppInterop.unregisterResponseRequired(comps[selectedComponent].connMap[1][0].toId);
		}

		GraphSynthInvoke.removeComp(Comp2remove);
		comps.Remove(selectedComponent);
		List<node> b = GraphSynthInvoke.GetNodes();
		List<arc> c = GraphSynthInvoke.GetArcs();


		BuildCode.outputPins.Clear();
		buildCanvas!.connLines.Clear();
		foreach (var comp in comps.Values)
		{
			updatePinBindings(comp);   //keep an eye on this. could be not good for performance.
		}

		int numofcon = 0;
		for (int i = 0; i < c.Count; i++)
		{
			if (c[i].localLabels.Contains("connection"))
			{
				numofcon++;
			}
		}
		Console.WriteLine("the number of nodes is " + b.Count);
		Console.WriteLine("the number of connections is " + numofcon);
	}

	private void handleKeyPress(KeyboardEventArgs e)
	{
		Console.WriteLine(e.Key);
		if (!isRunning && ((e.Key == "Backspace" || e.Key =="Delete") && selectedComponent!=-2 && selectedComponent!=-1))
		{
			removecomp();
		}
	}

	//progress bar
	public double loadingProgress = 0;

	private void HandleZoom(string action)
	{
		const double zoomStep = 0.1;

		if (action == "in")
		{
			buildCanvas!.zoomFactor -= zoomStep;
		}
		else if (action == "out")
		{
			buildCanvas!.zoomFactor += zoomStep;
		}

		buildCanvas!.zoomFactor = Math.Clamp(buildCanvas!.zoomFactor, .4, 3);

		StateHasChanged();
	}



	public async Task loadFromFile(InputFileChangeEventArgs e)
	{
		var file = e.File;
		var buffer = new byte[file.Size];
		await e.File.OpenReadStream(512000).ReadAsync(buffer);
		var str = System.Text.Encoding.UTF8.GetString(buffer);
		Data data = DeserializeJSON(str);
		comps.Clear();
		buildCanvas!.connLines.Clear();
		GraphSynthInvoke.inputs.Clear();
		GraphSynthInvoke.destroyGraph();
		BuildCode.outputPins.Clear();

		//Console.WriteLine(ex);
		localIds = data.LocalId;

		foreach (var kv in data.Comps)
		{
			comps.Add(kv.Key, kv.Value);
			var n = new node();//label with localId (easy tracking)
			n.localLabels.Add("user_" + kv.Value.data.nodeName);
			kv.Value.gsNode = n;

			GraphSynthInvoke.GetNodes().Add(n);
			GraphSynthInvoke.inputs.Add(kv.Value.data.nodeName);
			GraphSynthInvoke.recg_apply();
			GraphSynthInvoke.GetNodes().FindAll(n => n.localLabels.Find(s => s.StartsWith("localId:")) == null).ToList().ForEach(n => n.localLabels.Add("localId:" + kv.Key));
			GraphSynthInvoke.GetArcs().FindAll(a => a.localLabels.Find(s => s.StartsWith("localId:")) == null).ToList().ForEach(a => a.localLabels.Add("localId:" + kv.Key));

		}

		foreach (var c in comps.Values)
		{
			updatePinBindings(c);   //keep an eye on this. could be not good for performance.
		}
		setupListeners();

		AppInterop.setCodeWrapper(data.Code);
	}

	public async void downloadFile()
	{
		var stream = new MemoryStream();
		var writer = new StreamWriter(stream);
		writer.Write(await ExportJSON());
		writer.Flush();
		stream.Position = 0;

		using var streamRef = new DotNetStreamReference(stream: stream, leaveOpen: true);

		AppInterop.downloadFile("adarc-circuit.adarc", streamRef);
	}


	class Data
	{
		// public List<InstanceConnection> ConnLines { get; set; }
		public int LocalId { get; set; }
		public string Code { get; set; }
		public Dictionary<int, ComponentInstance> Comps { get; set; }
	}
	private async Task<string> ExportJSON(){
		Data parentObject = new Data
		{
			// ConnLines = Index.buildCanvas.connLines,
			Comps = comps,
			LocalId = localIds,
			Code = await AppInterop.getCodeWrapper()
		};

		var options = new JsonSerializerOptions { IncludeFields = true};
		options.Converters.Add(new ParamSerializer());
		return JsonSerializer.Serialize(parentObject,options);
	}

	private Data DeserializeJSON(string jsonString)
	{
		try
		{
			// Deserialize JSON data into a Data object
			var options = new JsonSerializerOptions { IncludeFields = true };
			options.Converters.Add(new ParamSerializer());
			Data canvasData = JsonSerializer.Deserialize<Data>(jsonString, options);

			// Now you have access to the deserialized data as a CanvasData object
			// Do whatever you need with this data

			return canvasData;
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error during deserialization: {ex.Message}");
		}

		return null;
	}

	// runs the introjs tutorial
	private async Task runTutorial()
	{
		// var module = await JS.InvokeAsync<IJSObjectReference>("window.backendManager.getBackendManager");
		// ant-menu-submenu-hidden
		await AppInterop.jsModule!.InvokeAsync<object>("runTutorial");
	}
}