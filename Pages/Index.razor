@page "/"
@using GraphSynth.Representation
@using System.IO
@using System.IO.Compression
@using System.Linq
@using ADArCWebApp.Shared.Data
@using ADArCWebApp.Shared.UIComponents
@inject IJSRuntime JsRuntime
@inject NavigationManager navMan
@inject BoardService BoardService
@inject ToastService ToastService
@inject GraphSynthInvoke GraphSynthInvoke

<PageTitle>Home | ADArC</PageTitle>
<body>
<script suppress-error="BL9992" type="module" src="build/build.js"></script>
<button @ref="refresh" hidden="hidden" @onclick="StateChanged">refresh</button>
@if (_isMobileUser)
{
    <div style="width: 100vw;
                height: 100vh;
                position: absolute;
                z-index: 10000000000;
                display: flex;
                align-items: center;
                justify-content: center;
                background-color: white;
                text-align: center;
                padding: 20px;
                font-family: Arial, sans-serif;">
        <div>
            <h2 style="font-weight: bold">Unsupported Device</h2>
            <p style="color: black; font-size: 18px;">
                This web application is not designed for mobile devices.
                Please access it from a desktop or laptop for the best experience.
            </p>
        </div>
    </div>
}
@if (shouldShowBoardSelect)
{
    <BoardSelect OnSelect="HandleBoardSelect" @ref="boardSelect"></BoardSelect>
}
<div class="page" data-title="Welcome to ADArC" data-intro="ADArC stands for Automated Design tool for Arduino Circuits! This is a circuit design tool for building projects with Arduino Microcontrollers.">
    <div class="toolbar" data-title="Toolbar" data-intro="The Toolbar contains tools to research, create, modify, and run your project.">
        <div class="logo-and-adarc">
            <img class="logo" src="images/adarc-logo.001.png" alt="adarc-logo">
            <span class="adarc-text">ADArC</span>
        </div>
        
        <button class="tutorial-button toolbar-button" style="font-size: 18px" @onclick="RunTutorial" data-title="Tutorial" data-intro="Click here to run this tutorial.">
            💡 Tutorial
        </button>
        <div class="center-toolbar">
            <div style="display: flex" data-title="Undo and Redo" data-intro="These buttons allow you to undo the last action or redo a previously undone action. You can use them to revert or restore changes such as adding or removing components.">
                <button class="toolbar-button" @onclick="() => { allowDrop = true; Undo(); SelectedComponent = -1; allowDrop = false; }"
                        disabled="@(_lastExecutedAction == null)">
                    <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-undo"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>Undo</span>
                </button>
                <button class="toolbar-button" @onclick="() => { allowDrop = true; Redo(); SelectedComponent = -1; allowDrop = false; }"
                        disabled="@(_lastUndoneAction == null)">
                    <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-redo"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/></svg>Redo</span>
                </button>
            </div>
            <div class="Import-Export" data-title="Import & Export Buttons" data-intro="Click the Import button on an empty workbench to load in a previous project. Click the Export button to save your current project to a file.">
                <InputFile id="import-button" accept=".adarc" style="display:none;" OnChange="@(IsRunning || selLockedOut ? null : LoadFromFile)" disabled="@(IsRunning || selLockedOut)"/>
                <label for="import-button" class="toolbar-button" style="pointer-events:@(IsRunning || selLockedOut ? "none" : "auto"); opacity: @(IsRunning || selLockedOut ? "0.25" : "1.0")">
                    <span>⬇️️ Import</span>
                </label>
                <button @onclick="@(IsRunning || selLockedOut ? null : DownloadFile)" class="toolbar-button" disabled="@(IsRunning || selLockedOut)">
                    <span>⬆️ Export</span>
                </button>
            </div>

            <button class="toolbar-button" @onclick="@(selLockedOut ? null : ToggleUrlDisplay)" data-title="Generate a URL" data-intro="Click here to generate a copyable URL with your current circuit and code."
                    disabled="@selLockedOut">
                <span>🔗 Generate URL</span>
            </button>

            <button class="toolbar-button" @onclick="@(selLockedOut ? null : (() => _exampleModalOpen = true))" data-title="Examples" data-intro="Click here to load example circuits."
                    disabled="@selLockedOut">
                📖 Examples
            </button>

            <button class="toolbar-button" @onclick="@(selLockedOut ? null : ReportBug)" data-title="Report Bug" data-intro="Click here to report any bugs or issues you encounter."
                    disabled="@selLockedOut">
                <span>🐛 Report Bug</span>
            </button>

            <button class="toolbar-button" @onclick="@(selLockedOut ? null : OpenExternalHelp)" data-title="Help Button" data-intro="Click the Help button to go to the dedicated help website. This website contains useful information for each component in our library."
                    disabled="@selLockedOut">
                <span>ℹ Help</span>
            </button>

            <Modal Open="@isUrlBoxVisible" OnClose="() => isUrlBoxVisible = false">
                <div class="url-modal">
                    <input type="text" class="url-textbox" value="@generatedUrl" readonly/>
                    <button class="toolbar-button copy-button" @onclick="CopyUrlToClipboard">
                        <span>@copyButtonText</span>
                    </button>
                </div>
            </Modal>

            <Modal Open="@_reportBugModalOpen" OnClose="() => _reportBugModalOpen = false">
                <div class="report-bug-modal">
                    <p>You will be navigated to a separate Google Form. Would you like to proceed?</p>
                    <div class="modal-buttons">
                        <button class="no-button" @onclick="CloseReportBugModal">No</button>
                        <button class="yes-button" @onclick="ProceedToReportBug">Yes</button>
                    </div>
                </div>
            </Modal>

            <button disabled="@selLockedOut" class="toolbar-button" @onclick="ToggleRunStop" data-title="Run/Compile" data-intro="Click to run the code in the Code Panel. This will also simulate the components on the Workbench.">
                <span>@runStopText</span>
            </button>
        </div>
    </div>
    <div class="page-content" @onmousedown="CheckForCardDrag" @onmousemove="DragCardIfPossible" @onmouseup="async (e) => { AddToCanvasIfNecessary(e, true);}">
        <div class="main-canvas" tabindex="0" @onkeydown="HandleKeyPress" @ref="_mainCanvasContainer">
            <MainCanvas comps=@(Comps) handleMouseEnter="() => allowDrop = true" handleMouseLeave="() => allowDrop = false"></MainCanvas>
        </div>
        <div class="sidebar" style="width: 25%; left: @(leftPaneAlign + "%")" data-title="Component Palette" data-intro="You can choose from the library of components to create your project. All wires are automatically connected to the Arduino once you drag a component to the workbench.">
            <div class="expand-button expand-button-left" @onclick="ToggleLeftSidebar" style="left:100%;">
                @if (isLeftExpanded)
                {
                    <span>▶</span>
                }
                else
                {
                    <span>◀</span>
                }
            </div>
            <ComponentPane host="@this"></ComponentPane>
        </div>
        <div id="mover" style="pointer-events:none; position:absolute; top:@(moverOffsetTop)px; left:@(moverOffsetLeft)px; transform:translate(-50%, -50%); visibility:@isVisible; width:@(ComponentDeclarations.Components[moverId].rightOffset)px; height:@(ComponentDeclarations.Components[moverId].bottomOffset)px;">
            <VaryingComponent disableBorder=true posAbsolute="false" individualData="new(moverId, new(), 0, 0)" objId="@moverId" zoomFactor="1" DragStart="() => { }" DragProgress="() => { }" DragEnd="() => { }"></VaryingComponent>
        </div>
        <div class="sidebar-right" style="width: 40%; right: @(rightPaneAlign + "%")" data-title="Code Pane" data-intro="Click the blue arrow button below to open the Code Panel. This is where you can program the digital Arduino. It follows the same design as the Arduino IDE. Sample code is loaded for each component on the Workbench.">
            <div class="expand-button expand-button-right" @onclick="ToggleRightSidebar" style="right:100%;">
                @if (isRightExpanded)
                {
                    <span>▶</span>
                }
                else
                {
                    <span>◀</span>
                }
            </div>
            <CodePane></CodePane>
        </div>
        <Modal Open="@_exampleModalOpen" OnClose="() => _exampleModalOpen = false">
            <ExampleSelect ComponentFrequencies="_componentFrequencies" OnClose="() => _exampleModalOpen = false"></ExampleSelect>
        </Modal>
    </div>
    <ToastQueue></ToastQueue>
    @if (showZoomTooltip)
    {
        <div class="zoom-tooltip" style="background: #ece1be">
            <label>Use these buttons to zoom in and out of the Canvas.</label>
            <button @onclick="GotItClicked">Got it!</button>
        </div>
    }

    @if (LoadingProgress == -1)
    {
        <div class="workbench-title">
            <span @onclick="ShowRightClickTooltipFn">💡 Workbench</span>
        </div>
    }
    @if (showRightClickTooltip)
    {
        <div class="right-click-tooltip" style="background: #ece1be">
            <label>This is the Workbench.</label>
            <label style="font-size: 13.5px">Right-click components dragged from the Component Palette for environmental settings, information, and deletion. Each component added auto-generates code in the Code Panel, accessible by clicking the arrow icon on the right side of the screen.</label>
            <button @onclick="HideRightClickTooltip">Got it!</button>
        </div>
    }
    <script src="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.2.0/intro.min.js"></script>


</div>
<div class="progress-container" style="display: @(LoadingProgress < 0 ? "none" : "block"); position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%); width: 400px; height: 60px; padding: 25px; background-color: lightgray; border-radius: 10px;">
    <span style="display: inline-block; width: 100%; text-align: center; color: black; transform: translateY(-13px);">@(Math.Round(LoadingProgress, 0))% component rules loaded</span>
    <div class="progress-bar" style="width: @(LoadingProgress)%; height: 10px; background-color: dodgerblue; border-radius: 13px; transform: translateY(-10px);"></div>

</div>
</body>

@code{
    private Modal modal;
    private bool _exampleModalOpen;

    private ElementReference _mainCanvasContainer;

    private BoardSelect boardSelect;
    private bool shouldShowBoardSelect;

    bool isLeftExpanded = true;
    private string generatedUrl = string.Empty;
    bool isRightExpanded;

    private bool _scheduleBenchSetup;

    private FrequencyVector<int> _componentFrequencies = new();

    /// <summary>
    /// Percentage of screen that the left pane is pushed to the left.
    /// Default position (0) is fully on screen.
    /// </summary>
    int leftPaneAlign => isLeftExpanded ? 0 : -24;

    /// <summary>
    /// Percentage of screen that the right pane is pushed to the right.
    /// Default position (0) is fully on screen.
    /// </summary>
    int rightPaneAlign => isRightExpanded ? 0 : -39;

    string runStopText = "▶️ Run";
    public bool IsRunning;

    void ToggleLeftSidebar()
    {
        isLeftExpanded = !isLeftExpanded;
        isRightExpanded = false;
        StateHasChanged();
    }


    void ToggleRightSidebar()
    {
        isRightExpanded = !isRightExpanded;
        isLeftExpanded = false;
        StateHasChanged();
    }

    private void HandleBoardSelect(Board board)
    {
        Console.WriteLine($"HandleBoardSelect called with board: {board}");

        // Normal board selection flow - no auto-selection check needed
        BoardService.Board = board;
        Comps[0] = BoardService.GetComponentInstance();
        Console.WriteLine($"Board set to {board}, component instance created");

        if (LoadingProgress == -1)
        {
            Console.WriteLine("Loading progress complete, setting up bench from JSON");
            SetupBenchFromJsonString(BoardService.GetJson());
            CompPane!.ReleaseLockout();
            selLockedOut = false;
            StateHasChanged();
        }
        else
        {
            Console.WriteLine("Loading in progress, scheduling bench setup");
            _scheduleBenchSetup = true;
        }
    }


    /// <summary>
    /// Attempts to compile and run the code.
    /// </summary>
    /// <returns></returns>
    async Task ToggleRunStop()
    {
        if (!IsRunning)
        {
            runStopText = "Compiling...";
            var response = await AppInterop.CompileWrapper();


            if (response.stderr != "")
            {
                CodePane?.UpdateConsoleOutput(response.stderr, false);
                runStopText = "▶️ Run";
                //look for available error messages (format roughly error:linenum:columnnum:message)
                var caps = Regex.Match(response.stderr, ":([0-9]*?:[0-9]*?):").Captures;
                if (caps.Count > 0)
                {
                    string lineSection = caps.First().Value;
                    //cut off the colons at the beginning and end
                    lineSection = lineSection[1..^1];
                    //get the index of the middle colon
                    int mid = lineSection.IndexOf(":", StringComparison.Ordinal);
                    //grab line number only
                    int line = int.Parse(lineSection[0..^(lineSection.Length - mid)]);
                    //grab column number only
                    int column = int.Parse(lineSection[(mid + 1)..^0]);
                    //cut off error: to get message
                    string message = Regex.Match(response.stderr, "error:.*").Captures.First().Value[7..^0];
                    AppInterop.MakeMonacoErrorWrapper(message, line, column);
                }
            }
            else //no errors
            {
                CodePane?.UpdateConsoleOutput(response.stdout, false);
                AppInterop.ClearMonacoErrorsWrapper();
                AppInterop.StartSimWrapper();
                runStopText = "🟥 Stop";
                IsRunning = true;
            }
        }
        else //stop running
        {
            AppInterop.StopWrapper();
            CodePane!.CommitBuffer();
            CodePane!.UpdateConsoleOutput("Stopped.\n", false);
            runStopText = "▶️ Run";
            IsRunning = false;
        }
    }

    void OpenExternalHelp()
    {
        const string url = "https://adarc-help.mech.website/";
        JsRuntime.InvokeVoidAsync("window.open", url, "_blank");
    }


    public Index()
    {
        App = this;
    }

    /// <summary>
    /// Provides avenue for non-component classes to invoke render.
    /// </summary>
    public async Task StateChanged()
    {
        await InvokeAsync(StateHasChanged);
    }


    /// <summary>
    /// re-render is also triggered on events, so create an event with a triggered click.
    /// generally the same as previous and should be removed if possible.
    /// TODO: remove this function and associated objects (element in this file, mini-script that declares triggerClick in index.html)
    /// </summary>
    /// <returns></returns>
    public async Task TriggerRender()
    {
        await JsRuntime.InvokeAsync<object>("triggerClick", refresh);
    }

    private int localIds;


    /// <summary>
    /// main component storage. provides an arduino by default. The arduino is overwritten when rule loading finishes,
    /// but does not change visually (hopefully)
    /// </summary>
    public static readonly Dictionary<int, ComponentInstance> Comps = new()
    {
        // { 0, new ComponentInstance(1, null, 829, 219) }
    };


    public int SelectedComponent = -1;

    public static Index? App;
    public static MainCanvas? BuildCanvas;
    public static CodePane? CodePane;
    public static ComponentPane? CompPane;
    public const int DefaultScreenWidth = 1920;
    public static double CurrentWidthRatio = 1;
    public const int DefaultScreenHeight = 1080;
    public static double CurrentHeightRatio = 1;

    public static ElementReference? refresh;

    /// <summary>
    /// Does setup for javascript interop on page load.
    /// Defined by Blazor.
    /// </summary>
    /// <param name="firstRender">true if this is specifically the first render, false otherwise</param>
    /// <returns></returns>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Console.WriteLine("Blazor Load Completed!");

            AppInterop.Runtime = JsRuntime;
            AppInterop.JsModule = await AppInterop.GetModuleWrapper();

            AppInterop.UpdateScreenRatios(await AppInterop.GetWindowWidth(), await AppInterop.GetWindowHeight());
            //AppInterop.startSimWrapper();
            //AppInterop.updateCodeWrapper();
        }
    }


    #region component pane integration

    /// <summary>
    /// Dragged component global id. Used to transfer data out of the palette to this file.
    /// </summary>
    private int targetCardComponentId = -1;

    /// <summary>
    /// Controls what component is displayed while the drag is ongoing.
    /// </summary>
    private int moverId => targetCardComponentId == -1 ? 1 : targetCardComponentId;

    private string isVisible = "hidden";
    private bool allowDrop = false;

    private double moverOffsetTop = 0;
    private double moverOffsetLeft = 0;

    public void SetTargetId(int id)
    {
        targetCardComponentId = id;
    }

    //functions to handle component dragged from palette to workbench
    private void CheckForCardDrag(MouseEventArgs e)
    {
        if (e.Button != 0 || targetCardComponentId == -1) return;
        isVisible = "visible";
        moverOffsetLeft = e.ClientX;
        moverOffsetTop = e.ClientY;
    }

    private void DragCardIfPossible(MouseEventArgs e)
    {
        if (targetCardComponentId == -1) return;
        moverOffsetLeft = e.ClientX;
        moverOffsetTop = e.ClientY;
    }

    private async void AddToCanvasIfNecessary(MouseEventArgs e, bool trackHistory = false)
    {
        if (targetCardComponentId == -1) return;
        isVisible = "hidden";
        if (allowDrop) //ie, cursor is over the workbench
        {
            ++localIds;
            var componentData = ComponentDeclarations.Components[targetCardComponentId];
            var n = new node(); //label with localId (easy tracking)
            n.localLabels.Add("user_" + componentData.nodeName);

            GraphSynthInvoke.GetNodes().Add(n);
            if (componentData.nodeName != null) GraphSynthInvoke.Inputs.Add(componentData.nodeName);

            GraphSynthInvoke.Add();
            if (!GraphSynthInvoke.Connect(componentData.nodeName, "arduino", SelectArduinoNode))
            {
                moverOffsetLeft = 0;
                moverOffsetTop = 0;
                targetCardComponentId = -1;
                GraphSynthInvoke.RemoveConnectedComponent(n);
                return;
            }

            //label all new nodes and connections with the localid of the component that added them.
            GraphSynthInvoke.GetNodes().FindAll(node => node.localLabels.Find(s => s.StartsWith("localId:")) == null).ToList().ForEach(node => node.localLabels.Add("localId:" + localIds));
            GraphSynthInvoke.GetArcs().FindAll(a => a.localLabels.Find(s => s.StartsWith("localId:")) == null).ToList().ForEach(a => a.localLabels.Add("localId:" + localIds));
            //create frontend instance
            var comp = new ComponentInstance(targetCardComponentId, n, e.ClientX - (.5 * componentData.rightOffset), e.ClientY - (.5 * componentData.bottomOffset) - 50);
            comp.localId = localIds;
            Comps.Add(localIds, BuildCanvas?.UnZoom(comp)); //50 is height of toolbar
            BuildCode.outputPins.Clear();
            BuildCanvas!.ConnLines.Clear();
            //reset the way that component pins are bound to the arduino.
            //TODO: check for performance improvements here.
            foreach (var c in Comps.Values)
            {
                UpdatePinBindings(c); //keep an eye on this. could be not good for performance.
            }

            await comp.LinkController(JsRuntime);
            _componentFrequencies.IncrementFrequency(targetCardComponentId);

            //register the dht specifically to forced the arduino to pause while awaiting response from sensor
            //TODO: improve and generalize.
            if (Comps[localIds].GlobalId == 20)
            {
                //Console.WriteLine("wait for:" + comps[localIds].connMap[1][0].toId);
                AppInterop.RegisterResponseRequired(Comps[localIds].ConnMap[1][0].ToId);
            }

            AppInterop.UpdateCodeWrapper();
            await JsRuntime.InvokeVoidAsync("onLoad");
            await JsRuntime.InvokeVoidAsync("onAppend");
            ToastService.AddToast("Code panel updated.", Variant.Info);
            if (comp.Data.Warning != null) ToastService.AddToast(comp.Data.Warning, Variant.Warning);
            if (trackHistory)
            {
                ExecuteAction(new UserAction(comp.localId, comp.GlobalId, UserActionType.Add, new MouseEventArgs{ClientX = e.ClientX, ClientY = e.ClientY}));
            }
        }


        moverOffsetLeft = 0;
        moverOffsetTop = 0;
        targetCardComponentId = -1;
    }

    // State for the Report Bug modal
    private bool _reportBugModalOpen = false;

    // Open the Report Bug modal
    private void OpenReportBugModal()
    {
        _reportBugModalOpen = true;
    }

    // Close the Report Bug modal
    private void CloseReportBugModal()
    {
        _reportBugModalOpen = false;
    }

    // Proceed to the Google Form
    private void ProceedToReportBug()
    {
        _reportBugModalOpen = false; // Close the modal
        const string googleFormUrl = "https://docs.google.com/forms/d/e/1FAIpQLSdI9w3ABXX34mRSPd0VRiu5LT63fRXSKzNQKhZypOkse2YuiA/viewform?usp=dialog";
        JsRuntime.InvokeVoidAsync("window.open", googleFormUrl, "_blank");
    }

    // Update the ReportBug method to open the modal instead of navigating directly
    private void ReportBug()
    {
        OpenReportBugModal();
    }

    private node? SelectArduinoNode(List<node> nodes, HashSet<string> labels)
    {
        List<node> i2cNodes = [];
        List<node> pwmNodes = [];
        List<node> analogNodes = [];
        List<node> usartNodes = [];
        List<node> spiNodes = [];
        List<node> connectedCandidates = [];
        bool isSpecial = labels.Contains("sda") || labels.Contains("scl") || labels.Contains("rx") ||
                         labels.Contains("tx") || labels.Contains("pwm") || labels.Contains("analog") ||
                         labels.Contains("sck") || labels.Contains("cipo") || labels.Contains("copi");
        bool sharedConnection = labels.Contains("sda") || labels.Contains("scl") || labels.Contains("sck") || labels.Contains("copi") || labels.Contains("cipo");
        foreach (var node in nodes)
        {
            var localLabels = new HashSet<string>(node.localLabels);
            // if this is the case, this is definetly not the node we are looking for.
            if (!labels.IsSubsetOf(localLabels)) continue;
            // this node is correct, but already has a connection. we mark this for error reporting.
            if (localLabels.Contains("connected") || (localLabels.Contains("bus") && !sharedConnection))
            {
                connectedCandidates.Add(node);
                continue;
            }

            // if we are looking for a special node, stop here
            if (isSpecial)
            {
                if (sharedConnection && !localLabels.Contains("bus"))
                {
                    node.localLabels.Add("bus");
                }

                return node;
            }

            // if we are looking for a GPIO pin, try to protect special pins
            if (localLabels.Contains("sda") || localLabels.Contains("scl"))
            {
                i2cNodes.Add(node);
            }
            else if (localLabels.Contains("pwm"))
            {
                pwmNodes.Add(node);
            }
            else if (localLabels.Contains("analog"))
            {
                analogNodes.Add(node);
            }
            else if (localLabels.Contains("tx") || localLabels.Contains("rx"))
            {
                usartNodes.Add(node);
            }
            else if (localLabels.Contains("copi") || localLabels.Contains("cipo") || localLabels.Contains("sck"))
            {
                spiNodes.Add(node);
            }
            else // if we have found a non-reserved node
            {
                return node;
            }
        }

        // Fallback priority: PWM -> USART -> Analog -> SPI -> I2C
        node? selectedNode = null;
        if (pwmNodes.Count > 0)
        {
            selectedNode = pwmNodes.First();
        }
        else if (usartNodes.Count > 0)
        {
            selectedNode = usartNodes.First();
        }
        else if (analogNodes.Count > 0)
        {
            selectedNode = analogNodes.First();
        }
        else if (spiNodes.Count > 0)
        {
            selectedNode = spiNodes.First();
        }
        else if (i2cNodes.Count > 0)
        {
            selectedNode = i2cNodes.First();
        }

        // Return the selected fallback node or null if no match was found
        if (selectedNode != null) return selectedNode;
        List<string> connectedComponentNames = [];
        List<string> connectedPinNames = [];
        List<ComponentInstance> connectedComponents = [];
        foreach (var candidate in connectedCandidates)
        {
            var pinName = "";
            foreach (var label in candidate.localLabels)
            {
                if (Regex.IsMatch(label, @"a\d+"))
                {
                    pinName = label;
                    break;
                }

                if (Regex.IsMatch(label, @"d\d+"))
                {
                    pinName = label;
                }
            }

            var componentPin = candidate.arcsFrom.Find(a => a.localLabels.Contains("connection"))?.To ?? candidate.arcsTo.Find(a => a.localLabels.Contains("connection"))?.From;
            var componentNode = componentPin?.arcsFrom.Find(a => !a.localLabels.Contains("connection"))?.To ?? componentPin?.arcsTo.Find(a => !a.localLabels.Contains("connection"))?.From;
            if (componentNode != null)
            {
                var componentIdLabel = componentNode.localLabels.Find(l => l.Contains("localId:"));
                if (componentIdLabel != null)
                {
                    var connectedComponentId = int.Parse(componentIdLabel[8..]);
                    connectedPinNames.Add(pinName);
                    connectedComponentNames.Add(componentNode.localLabels.First());
                    connectedComponents.Add(Comps[connectedComponentId]);
                }
            }
        }

        var message = "No more pins are available. Try removing ";
        for (int i = 0; i < Math.Min(3, connectedComponentNames.Count); i++)
        {
            if (i == Math.Min(3, connectedComponentNames.Count) - 2)
            {
                message += $"{connectedComponentNames[i]} on pin {connectedPinNames[i]} or ";
            }
            else if (i < Math.Min(3, connectedComponentNames.Count) - 1)
            {
                message += $"{connectedComponentNames[i]} on pin {connectedPinNames[i]}, ";
            }
            else
            {
                message += $"{connectedComponentNames[i]} on pin {connectedPinNames[i]}.";
            }
        }

        ToastService.AddToast(message, Variant.Error, connectedComponents.Take(3));
        return selectedNode;
    }

    #endregion

    /// <summary>
    /// Disables the palette until rules are loaded.
    /// </summary>
    private bool selLockedOut = true;

    private bool _isMobileUser;

    /// <summary>
    /// This is triggered exactly once when blazor is loaded, but before render if I remember correctly.
    /// In general, order is html load -> this -> render
    /// </summary>
    /// <returns></returns>
    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("OnInitializedAsync started");

        // Initialize JS interop first
        if (AppInterop.JsModule == null)
        {
            Console.WriteLine("Initializing JS interop");
            AppInterop.Runtime = JsRuntime;
            AppInterop.JsModule = await AppInterop.GetModuleWrapper();
        }

        _isMobileUser = await AppInterop.IsMobileUser();
        
        // Check if we're loading from a URL
        var uri = new Uri(navMan.Uri);
        var queryParams = System.Web.HttpUtility.ParseQueryString(uri.Query);
        var hasUrlParam = !string.IsNullOrEmpty(queryParams["c"]);
        var isExample = !string.IsNullOrEmpty(queryParams["e"]);
        shouldShowBoardSelect = !hasUrlParam;
        StateHasChanged();
        Console.WriteLine($"Should show board select: {shouldShowBoardSelect} (URL parameter present: {hasUrlParam})");

        // Only lock selection if we're not loading from URL uhm
        // selLockedOut = !hasUrlParam;

        Console.WriteLine("Loading rulesets...");
        var x = await RuleSetMap.GetInstance().LoadRuleSet("ADD", navMan, this, 0, 58);
        await RuleSetMap.GetInstance().LoadRuleSet("CONNECT", navMan, this, x, 58);

        GraphSynthInvoke.rulesets = RuleSetMap.Rulesets;
        
        if (hasUrlParam)
        {
            await LoadFromUrl(queryParams["c"], isExample);
        }


        if (_scheduleBenchSetup)
        {
            Console.WriteLine("Setting up bench from JSON");
            await SetupBenchFromJsonString(BoardService.GetJson());
            CompPane!.ReleaseLockout();
            selLockedOut = false;
            StateHasChanged();
        }

        LoadingProgress = -1;
        Console.WriteLine("OnInitializedAsync completed");

        StateHasChanged();
    }

    /// <summary>
    /// sets up a components pin bindings to an arduino.
    /// TODO: improve this function or find a way to remove it entirely.
    /// </summary>
    /// <param name="comp">A component instance to update the bindings on.</param>
    private void UpdatePinBindings(ComponentInstance comp)
    {
        comp.ConnMap.Clear();
        //buildCanvas!.connLines.Clear();

        var compPins = GetPins(comp.GsNode, comp.Data.nodeName);
        if (compPins.Count == 0)
        {
            return;
        }

        var connArcs = GraphSynthInvoke.GetArcs().Where(a => a.localLabels.Contains("connection")).ToList();
        //List<arc> connArcs = new();

        foreach (arc a in connArcs)
        {
            ComponentInstance ha = Comps[Convert.ToInt32(a.To.localLabels.Find(s => s.StartsWith("localId:")).Substring(8))];
            ComponentInstance hb = Comps[Convert.ToInt32(a.From.localLabels.Find(s => s.StartsWith("localId:")).Substring(8))];


            if (ha == hb)
            {
                continue;
            }

            if (ha != comp && hb != comp)
            {
                continue;
            }

            if (ha != comp)
            {
                (ha, hb) = (hb, ha);
            }

            var aPinName = "**NF**";

            if ((ha.IsArduino() && (a.To.localLabels.Contains("localId:1") || a.To.localLabels.Contains("localId:2"))) || (!ha.IsArduino() && !(a.To.localLabels.Contains("localId:1") || a.To.localLabels.Contains("localId:2"))))
            {
                aPinName = (from df in ha.Data.pins.Keys where a.To.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
            }

            string bPinName = "";


            if (aPinName == "**NF**")
            {
                aPinName = (from df in ha.Data.pins.Keys where a.From.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
                bPinName = (from df in hb.Data.pins.Keys where a.To.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
            }
            else
            {
                bPinName = (from df in hb.Data.pins.Keys where a.From.localLabels.Contains(df) select df).FirstOrDefault("**NF**");
            }

            //if arduino and data pin being connected, register to code.
            if ((ha.IsArduino()) && System.Text.RegularExpressions.Regex.Match(aPinName, "d[0-9]{1,2}").Success)
            {
                BuildCode.outputPins.Add(Convert.ToInt32(aPinName.Substring(1)));
                //Console.WriteLine("1: " + BuildCode.outputPins.Count);
            }

            if (aPinName == "**NF**")
            {
                Console.WriteLine(ha.Data.name + " is missing a pin definition!");
            }

            if (bPinName == "**NF**")
            {
                Console.WriteLine(hb.Data.name + " is missing a pin definition!");
            }

            int i1 = ha.Data.pins[aPinName];
            int i2 = hb.Data.pins[bPinName];


            comp.AddConnection(i1, hb, i2, a); //also sets up the drawn line
        }
    }

    /// <summary>
    /// Helper for updatePinBindings to get all pins of a component as graphsynth nodes.
    /// </summary>
    /// <param name="n">The node to get the pins of. Specifically, the root node, not the main node.</param>
    /// <param name="name">The name of the root node, excluding "user_".</param>
    /// <returns></returns>
    private static List<node> GetPins(node n, string name)
    {
        //n is root, connected to main node but not main node.
        var fullName = "user_" + name;
        if (n.arcs.Count == 0)
        {
            return [];
        }

        var mainNode = ((arc)n.arcs[0]).otherNode(n);
        //traverse arcs to get pin nodes, except the root node
        var potential = mainNode.arcs.Select(a => ((arc)a).otherNode(mainNode)).ToList();
        return potential.Where(node => !node.localLabels.Contains(fullName)).ToList();
    }

    /// <summary>
    /// Deletes a component.
    /// </summary>
    public async void RemoveComp(bool suppressToast = false, bool trackHistory = false)
    {
        var removedComponent = Comps[SelectedComponent];
        if (trackHistory)
        {
            var clientX = removedComponent.X + 0.5 * removedComponent.Data.rightOffset;
            var clientY = removedComponent.Y + 0.5 * removedComponent.Data.bottomOffset + 50;
            ExecuteAction(new UserAction(SelectedComponent, removedComponent.GlobalId, UserActionType.Remove, new MouseEventArgs { ClientX = clientX, ClientY = clientY}));
        }
        _componentFrequencies.DecrementFrequency(removedComponent.GlobalId);

        //specifically deregisters the dht pins from requiring a pause on the arduino.
        //TODO: improve and generalize.
        if (removedComponent.GlobalId == 20)
        {
            AppInterop.UnregisterResponseRequired(Comps[SelectedComponent].ConnMap[1][0].ToId);
        }

        GraphSynthInvoke.RemoveComp(removedComponent.GsNode);

        Comps.Remove(SelectedComponent);

        await removedComponent.DisposeAsync();

        BuildCode.outputPins.Clear();
        BuildCanvas!.ConnLines.Clear();
        foreach (var comp in Comps.Values)
        {
            UpdatePinBindings(comp); //keep an eye on this. could be not good for performance.
        }

        StateHasChanged();
        if (!suppressToast) ToastService.AddToast("Code panel updated.", Variant.Info);
        await JsRuntime.InvokeVoidAsync("onDelete");
        AppInterop.UpdateCodeWrapper();
        await JsRuntime.InvokeVoidAsync("onLoad");
        await JsRuntime.InvokeVoidAsync("onAppend");
    }

    /// <summary>
    /// Deletes a component when delete/backspace pressed.
    /// </summary>
    /// <param name="e"></param>
    private void HandleKeyPress(KeyboardEventArgs e)
    {
        if (IsRunning) return;
        if (e.Key == "z" && e.CtrlKey) Undo();
        else if (e.Key == "y" && e.CtrlKey) Redo();
        // 1 is the arduino, not sure what -2 or -1 is
        if ((e.Key is not ("Backspace" or "Delete")) || SelectedComponent == -2 || SelectedComponent == -1 || SelectedComponent == 1) return;
        RemoveComp(false, true);
        SelectedComponent = -1;
    }

    //progress bar
    public double LoadingProgress;

    //unused
    private void HandleZoom(string action)
    {
        const double zoomStep = 0.1;

        if (action == "in")
        {
            BuildCanvas!.zoomFactor -= zoomStep;
        }
        else if (action == "out")
        {
            BuildCanvas!.zoomFactor += zoomStep;
        }

        BuildCanvas!.zoomFactor = Math.Clamp(BuildCanvas!.zoomFactor, .4, 3);

        StateHasChanged();
    }

    bool showZoomTooltip = false;
    bool labelShownBefore = false;

    void ShowLabel()
    {
        if (!labelShownBefore)
        {
            showZoomTooltip = true;
        }
    }

    void HideLabel()
    {
        showZoomTooltip = false;
    }

    void GotItClicked() //for zoom tooltip
    {
        labelShownBefore = true;
        showZoomTooltip = false;
    }

    bool showRightClickTooltip = false;

    void HideRightClickTooltip()
    {
        showRightClickTooltip = false;
    }

    void ShowRightClickTooltipFn()
    {
        showRightClickTooltip = true;
    }


    /// <summary>
    /// When a file is imported, handle it.
    /// </summary>
    /// <param name="e"></param>
    /// <returns></returns>
    public async Task LoadFromFile(InputFileChangeEventArgs e)
    {
        Console.WriteLine("LoadFromFile called");
        try
        {
            var file = e.File;
            Console.WriteLine($"Processing file: {file.Name}, size: {file.Size}");

            var buffer = new byte[file.Size];
            await e.File.OpenReadStream().ReadAsync(buffer);
            var str = System.Text.Encoding.UTF8.GetString(buffer);
            Console.WriteLine("File content loaded successfully");

            try
            {
                Console.WriteLine("Parsing file JSON data");
                var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true,
                    IncludeFields = true
                };
                options.Converters.Add(new ParamSerializer());
                var data = JsonSerializer.Deserialize<Data>(str, options);

                if (data?.Comps != null && data.Comps.ContainsKey(1))
                {
                    var boardType = data.Comps[1].GlobalId == 1 ? Board.ArduinoUno : Board.ArduinoMega;
                    Console.WriteLine($"Detected board type from file: {boardType}");

                    Console.WriteLine("Setting board type");
                    BoardService.Board = boardType;

                    Console.WriteLine("Setting up bench");
                    SetupBenchFromJsonString(str);

                    // Unlock components
                    Console.WriteLine("Unlocking components");
                    selLockedOut = false;
                    StateHasChanged();
                    if (CompPane != null)
                    {
                        CompPane.ReleaseLockout();
                    }

                    Console.WriteLine("File import complete");
                }
                else
                {
                    Console.WriteLine("Error: Could not find board type in file data");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing file contents: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
                if (str.Length > 0)
                {
                    Console.WriteLine($"JSON content: {str.Substring(0, Math.Min(200, str.Length))}...");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Critical error in LoadFromFile: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
        }
    }

    /// <summary>
    /// Handles most of the setup process of the bench after import.
    /// </summary>
    /// <param name="json">The full JSON to deserialize.</param>
    private static Data? DeserializeJson(string jsonString)
    {
        Console.WriteLine("Starting JSON deserialization");
        try
        {
            var options = new JsonSerializerOptions
            {
                IncludeFields = true,
                WriteIndented = true
            };
            options.Converters.Add(new ParamSerializer());

            Data? canvasData = JsonSerializer.Deserialize<Data>(jsonString, options);

            if (canvasData == null)
            {
                Console.WriteLine("Deserialization returned null");
                return null;
            }

            Console.WriteLine($"Deserialization successful. Component count: {canvasData.Comps?.Count ?? 0}");
            return canvasData;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during deserialization: {ex.Message}");
            Console.WriteLine($"JSON content: {jsonString.Substring(0, Math.Min(200, jsonString.Length))}..."); // Show start of JSON for debugging
            return null;
        }
    }

    private async Task SetupBenchFromJsonString(string json)
    {
        Console.WriteLine("Starting bench setup from JSON");
        Data? data;
        try
        {
            var options = new JsonSerializerOptions
            {
                IncludeFields = true,
                WriteIndented = true
            };
            options.Converters.Add(new ParamSerializer());
            data = JsonSerializer.Deserialize<Data>(json, options);

            if (data == null)
            {
                Console.WriteLine("Deserialization returned null");
                return;
            }

            Console.WriteLine($"Deserialization successful. Component count: {data.Comps?.Count ?? 0}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during deserialization: {ex.Message}");
            Console.WriteLine($"JSON content: {json.Substring(0, Math.Min(200, json.Length))}...");
            return;
        }

        try
        {
            // Clear existing components
            foreach (var comp in Comps)
            {
                Console.WriteLine($"Removing component {comp.Key}");
                SelectedComponent = comp.Key;
                RemoveComp(true);
                SelectedComponent = -1;
            }

            BuildCanvas!.ConnLines.Clear();
            BuildCanvas.ResetTransform();
            GraphSynthInvoke.Inputs.Clear();
            GraphSynthInvoke.DestroyGraph();
            BuildCode.outputPins.Clear();
            localIds = data.LocalId;

            // First pass: Create all component nodes
            foreach (var kv in data.Comps.OrderBy(kv => kv.Key))
            {
                Console.WriteLine($"Setting up component {kv.Key} of type {kv.Value.Data.nodeName}");
                Comps.Add(kv.Key, kv.Value);
                _componentFrequencies.IncrementFrequency(kv.Value.GlobalId);
                var n = new node();
                n.localLabels.Add("user_" + kv.Value.Data.nodeName);
                kv.Value.GsNode = n;

                GraphSynthInvoke.GetNodes().Add(n);
                if (kv.Value.Data.nodeName != null)
                {
                    GraphSynthInvoke.Inputs.Add(kv.Value.Data.nodeName);
                    Console.WriteLine($"Added input for {kv.Value.Data.nodeName}");
                }

                // Add and connect each component
                GraphSynthInvoke.Add();
                if (kv.Value.Data.nodeName != null && !kv.Value.IsArduino())
                {
                    var connected = GraphSynthInvoke.Connect(kv.Value.Data.nodeName, "arduino", SelectArduinoNode);
                    Console.WriteLine($"Connected component {kv.Key}: {connected}");
                }

                // Label nodes and arcs with localId
                var newNodes = GraphSynthInvoke.GetNodes()
                    .FindAll(node => node.localLabels.Find(s => s.StartsWith("localId:")) == null);
                var newArcs = GraphSynthInvoke.GetArcs()
                    .FindAll(a => a.localLabels.Find(s => s.StartsWith("localId:")) == null);

                foreach (var node in newNodes)
                {
                    node.localLabels.Add("localId:" + kv.Key);
                }

                foreach (var arc in newArcs)
                {
                    arc.localLabels.Add("localId:" + kv.Key);
                }

                Console.WriteLine($"Labeled {newNodes.Count} nodes and {newArcs.Count} arcs for component {kv.Key}");
            }

            // Second pass: Update bindings and setup listeners
            foreach (var comp in Comps.Values)
            {
                UpdatePinBindings(comp);
                if (!comp.IsArduino()) await comp.LinkController(JsRuntime);

                // Re-register DHT if present
                if (comp.GlobalId == 20)
                {
                    if (comp.ConnMap.ContainsKey(1) && comp.ConnMap[1].Count > 0)
                    {
                        AppInterop.RegisterResponseRequired(comp.ConnMap[1][0].ToId);
                        Console.WriteLine("Registered DHT component");
                    }
                }
            }
            
            BuildCanvas.ResetTransform();
            Console.WriteLine("Setting code");
            AppInterop.SetCodeWrapper(data.Code);
            StateHasChanged();
            Console.WriteLine("Bench setup complete");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during bench setup: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            throw;
        }
    }

    /// <summary>
    /// Create file data and send it off to JS for downloading.
    /// </summary>
    public async void DownloadFile()
    {
        var stream = new MemoryStream();
        var writer = new StreamWriter(stream);
        await writer.WriteAsync(await ExportJson());
        await writer.FlushAsync();
        stream.Position = 0;

        using var streamRef = new DotNetStreamReference(stream: stream, leaveOpen: true);

        AppInterop.DownloadFile("adarc-circuit.adarc", streamRef);
    }


    class Data
    {
        // public List<InstanceConnection> ConnLines { get; set; }
        public int LocalId { get; set; }
        public string Code { get; set; }
        public Dictionary<int, ComponentInstance> Comps { get; set; }
    }

    /// <summary>
    /// Creates a JSON string representing most of the current state of the circuit.
    /// </summary>
    /// <returns>A JSON string of a Data object.</returns>
    private async Task<string> ExportJson()
    {
        Console.WriteLine("Starting JSON export");
        try
        {
            // Create clean component dictionary without Controller references
            var cleanComps = new Dictionary<int, ComponentInstance>();
            foreach (var kvp in Comps)
            {
                var comp = kvp.Value;
                cleanComps.Add(kvp.Key, comp);
            }

            Data parentObject = new Data
            {
                Comps = cleanComps,
                LocalId = localIds,
                Code = await AppInterop.GetCodeWrapper()
            };

            var options = new JsonSerializerOptions
            {
                IncludeFields = true,
                WriteIndented = true // Makes JSON more readable for debugging
            };
            options.Converters.Add(new ParamSerializer());

            var json = JsonSerializer.Serialize(parentObject, options);
            Console.WriteLine($"JSON export successful. Length: {json.Length}");

            return json;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during JSON export: {ex.Message}");
            throw;
        }
    }


    // runs the introjs tutorial
    public async void RunTutorial()
    {
        // var module = await JS.InvokeAsync<IJSObjectReference>("window.backendManager.getBackendManager");
        // ant-menu-submenu-hidden
        await AppInterop.JsModule!.InvokeVoidAsync("runTutorial");
        //await AppInterop.jsModule!.InvokeVoidAsync("runTutorial", true);
        StateHasChanged();
    }


    private string copyButtonText = "📋 Copy";

    private async Task CopyUrlToClipboard()
    {
        await JsRuntime.InvokeVoidAsync("navigator.clipboard.writeText", generatedUrl);
        copyButtonText = "✓ Copied!";
        StateHasChanged();

        // Reset button text after 2 seconds
        await Task.Delay(2000);
        copyButtonText = "📋 Copy";
        StateHasChanged();
    }


    private bool isUrlBoxVisible = false;

    private async Task ToggleUrlDisplay()
    {
        isUrlBoxVisible = !isUrlBoxVisible;
        copyButtonText = "📋 Copy"; // Reset text
    
        if (isUrlBoxVisible)
        {
            try
            {
                var json = await ExportJson();
                var compressed = await CompressCircuitData(json);
                var baseUrl = navMan.BaseUri;
                generatedUrl = $"{baseUrl}?c={compressed}";
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error generating URL: {ex.Message}");
                generatedUrl = "Error generating URL";
            }
        }
    
        StateHasChanged();
    }


    private static async Task<string> CompressCircuitData(string json)
    {
        try
        {
            // First validate the input JSON
            using (JsonDocument.Parse(json))
            {
            }

            // Apply replacements in order of longest pattern first
            foreach (var kvp in CompressionMap.OrderByDescending(x => x.Key.Length))
            {
                json = json.Replace(kvp.Key, kvp.Value);
            }

            byte[] jsonBytes = System.Text.Encoding.UTF8.GetBytes(json);
            using var msi = new MemoryStream(jsonBytes);
            using var mso = new MemoryStream();
            using (var gs = new GZipStream(mso, CompressionMode.Compress))
            {
                await msi.CopyToAsync(gs);
            }

            return Convert.ToBase64String(mso.ToArray())
                .Replace('+', '-')
                .Replace('/', '_')
                .Replace("=", "");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Compression error: {ex.Message}");
            throw;
        }
    }

    private static string DecompressCircuitData(string compressed)
    {
        try
        {
            // Handle Base64 padding
            compressed = compressed.Replace('-', '+').Replace('_', '/');
            switch (compressed.Length % 4)
            {
                case 2:
                    compressed += "==";
                    break;
                case 3:
                    compressed += "=";
                    break;
            }

            // Decompress
            byte[] compressedBytes = Convert.FromBase64String(compressed);
            using var msi = new MemoryStream(compressedBytes);
            using var mso = new MemoryStream();
            using (var gs = new GZipStream(msi, CompressionMode.Decompress))
            {
                gs.CopyTo(mso);
            }

            string json = System.Text.Encoding.UTF8.GetString(mso.ToArray());

            // First handle JSON structure (#-prefixed patterns) in reverse order
            foreach (var kvp in CompressionMap
                         .Where(x => x.Value.StartsWith("\"#"))
                         .OrderByDescending(x => x.Value.Length))
            {
                json = json.Replace(kvp.Value, kvp.Key);
            }

            // Then handle code patterns (@-prefixed) in reverse order
            foreach (var kvp in CompressionMap
                         .Where(x => x.Value.StartsWith("@"))
                         .OrderByDescending(x => x.Value.Length))
            {
                json = json.Replace(kvp.Value, kvp.Key);
            }

            // Finally handle whitespace patterns
            foreach (var kvp in CompressionMap
                         .Where(x => !x.Value.StartsWith("\"#") && !x.Value.StartsWith("@"))
                         .OrderByDescending(x => x.Value.Length))
            {
                json = json.Replace(kvp.Value, kvp.Key);
            }

            // Validate final JSON
            using (JsonDocument.Parse(json))
            {
            }

            return json;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Decompression error at: {ex.Message}");
            throw;
        }
    }
    
    // [JSInvokable]
    public static async Task LoadFromUrl(string compressedData, bool example = false)
    {
        try
        {
            Console.WriteLine("LoadFromUrl called with compressed data length: " + compressedData.Length);

            if (App == null)
            {
                Console.WriteLine("Error: App not ready");
                return;
            }

            try
            {
                // Handle Base64 padding
                compressedData = compressedData.Replace('-', '+').Replace('_', '/');
                switch (compressedData.Length % 4)
                {
                    case 2:
                        compressedData += "==";
                        break;
                    case 3:
                        compressedData += "=";
                        break;
                }

                // Decompress
                byte[] compressedBytes = Convert.FromBase64String(compressedData);
                using var msi = new MemoryStream(compressedBytes);
                using var mso = new MemoryStream();
                using (var gs = new GZipStream(msi, CompressionMode.Decompress))
                {
                    await gs.CopyToAsync(mso);
                }

                var json = System.Text.Encoding.UTF8.GetString(mso.ToArray());
                Console.WriteLine($"Successfully decompressed JSON data, length: {json.Length}");

                // Replace compressed patterns with original values
                foreach (var kvp in CompressionMap.OrderByDescending(x => x.Value.Length))
                {
                    json = json.Replace(kvp.Value, kvp.Key);
                }

                try
                {
                    // Parse JSON to get board type
                    Console.WriteLine("Parsing JSON data to determine board type");
                    var options = new JsonSerializerOptions
                    {
                        PropertyNameCaseInsensitive = true,
                        IncludeFields = true
                    };
                    options.Converters.Add(new ParamSerializer());

                    var data = JsonSerializer.Deserialize<Data>(json, options);
                    Console.WriteLine($"JSON deserialized successfully, checking components");

                    if (data?.Comps != null && data.Comps.ContainsKey(1))
                    {
                        var boardType = data.Comps[1].GlobalId == 1 ? Board.ArduinoUno : Board.ArduinoMega;
                        Console.WriteLine($"Detected board type from URL data: {boardType}");

                        await App.InvokeAsync(async () =>
                        {
                            Console.WriteLine("Setting shouldShowBoardSelect to false");
                            App.shouldShowBoardSelect = false;
                            App.StateHasChanged();

                            Console.WriteLine("Setting board type");
                            App.BoardService.Board = boardType;

                            Console.WriteLine("Setting up bench");
                            await App.SetupBenchFromJsonString(json);

                            // Unlock components after setup is complete
                            Console.WriteLine("Unlocking components");
                            App.selLockedOut = false;
                            if (CompPane != null)
                            {
                                CompPane.ReleaseLockout();
                            }

                            if (example)
                            {
                                App.ToastService.AddToast("Example loaded successfully. To navigate back to the previous workspace, click on the previous browser tab.", Variant.Info);
                            }
                            else
                            {
                                App.ToastService.AddToast("Load from URL complete", Variant.Info);
                            }

                            Console.WriteLine("Board and bench setup complete");
                        });

                        Console.WriteLine("Triggering state change");
                        await App.StateChanged();
                    }
                    else
                    {
                        Console.WriteLine("Error: Could not find board type in component data");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error parsing JSON or setting up bench: {ex.Message}");
                    Console.WriteLine($"Stack trace: {ex.StackTrace}");
                    Console.WriteLine($"JSON content: {json.Substring(0, Math.Min(200, json.Length))}...");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error decompressing data: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Critical error in LoadFromUrl: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
        }
    }

    private record UserAction(int LocalId, int GlobalId, UserActionType Type, MouseEventArgs MouseEventArgs);
    private enum UserActionType
    {
        Add,
        Remove,
    }

    private UserAction? _lastExecutedAction;
    private UserAction? _lastUndoneAction;

    private void Undo()
    {
        if (_lastExecutedAction == null) return;
        var lastAction = _lastExecutedAction;
        _lastExecutedAction = null; // Remove the stored undo action after using it
        _lastUndoneAction = lastAction with { LocalId = localIds + 1 }; // Store it for redo

        switch (lastAction.Type)
        {
            case UserActionType.Add:
                SelectedComponent = lastAction.LocalId;
                RemoveComp();
                break;
            case UserActionType.Remove:
                targetCardComponentId = lastAction.GlobalId;
                AddToCanvasIfNecessary(lastAction.MouseEventArgs);
                break;
        }
    }

    private void Redo()
    {
        if (_lastUndoneAction == null) return;
        var lastAction = _lastUndoneAction;
        _lastUndoneAction = null; // Remove the stored redo action after using it
        _lastExecutedAction = lastAction with { LocalId = localIds + 1 }; // Store it for undo

        switch (lastAction.Type)
        {
            case UserActionType.Add:
                targetCardComponentId = lastAction.GlobalId;
                AddToCanvasIfNecessary(lastAction.MouseEventArgs);
                break;
            case UserActionType.Remove:
                SelectedComponent = lastAction.LocalId;
                RemoveComp();
                break;
        }
    }

    private void ExecuteAction(UserAction action)
    {
        _lastExecutedAction = action;
        _lastUndoneAction = null; // Clear redo history whenever a new action is executed
    }


    private static readonly Dictionary<string, string> CompressionMap = new()
    {
        // JSON Structure (use numbered patterns to avoid collisions)
        { "\"LocalId\":", "\"#01:" },
        { "\"Comps\":{", "\"#02:{" },
        { "\"compParams\":", "\"#03:" },
        { "\"System.Double\"", "\"#04\"" },
        { "\"System.String\"", "\"#05\"" },
        { "\"System.Boolean\"", "\"#06\"" },
        { "\"System.Int32\"", "\"#07\"" },

        // Component Properties
        { "\"localId\":", "\"#11:" },
        { "\"globalId\":", "\"#12:" },
        { "\"x\":", "\"#13:" },
        { "\"y\":", "\"#14:" },
        { "\"zoomedX\":", "\"#15:" },
        { "\"zoomedY\":", "\"#16:" },
        { "\"midSignal\":", "\"#17:" },
        { "\"counter\":", "\"#18:" },
        { "\"Wbuffer\":", "\"#19:" },
        { "\"RegAddr\":", "\"#20:" },
        { "\"byteIndex\":", "\"#21:" },
        { "\"timer\":", "\"#22:" },
        { "\"type\":", "\"#23:" },
        { "\"value\":", "\"#24:" },

        // Component Numbers
        { "\"1\":{", "\"#31:{" },
        { "\"2\":{", "\"#32:{" },
        { "\"3\":{", "\"#33:{" },
        { "\"4\":{", "\"#34:{" },
        { "\"5\":{", "\"#35:{" },
        { "\"6\":{", "\"#36:{" },
        { "\"7\":{", "\"#37:{" },
        { "\"8\":{", "\"#38:{" },
        { "\"9\":{", "\"#39:{" },

        // Component Parameters
        { "\"triggermode\":", "\"#41:" },
        { "\"ismotiondetected\":", "\"#42:" },
        { "\"timedelayseconds\":", "\"#43:" },
        { "\"text\":", "\"#44:" },
        { "\"backlight\":", "\"#45:" },
        { "\"blink\":", "\"#46:" },
        { "\"cursor\":", "\"#47:" },
        { "\"cursorX\":", "\"#48:" },
        { "\"cursorY\":", "\"#49:" },

        // Include Statements
        { "#include <Arduino.h>", "@inc1" },
        { "#include <Wire.h>", "@inc2" },
        { "#include <LiquidCrystal_PCF8574.h>", "@inc3" },

        // Code Patterns (use @ for code patterns to distinguish from JSON #)
        { "int inputPin", "@ip" },
        { "const buzzerPin", "@bp" },
        { "int val", "@iv" },
        { "pinMode(inputPin, INPUT)", "@pmii" },
        { "pinMode(buzzerPin, OUTPUT);", "@pmbo" },
        { "void setup()", "@vs" },
        { "void loop()", "@vl" },
        { "val = digitalRead(inputPin)", "@vdri" },
        { "if (val == HIGH)", "@ifh" },

        // Delays
        { "delay(1000)", "@1k" },
        { "delay(2000)", "@2k" },
        { "delay(4000)", "@4k" },
        { "delay(5000)", "@5k" },
        { "delay(10000)", "@10k" },

        // PIR Code
        { "int pirState = LOW", "@pl" },
        { "int pirState = HIGH", "@ph" },
        { "if (pirState == LOW)", "@ipl" },
        { "if (pirState == HIGH)", "@iph" },
        { "Serial.println(\\u0022Motion detected!\\u0022)", "@spmd" },
        { "Serial.println(\\u0022Motion ended!\\u0022)", "@spme" },
        { "digitalWrite(buzzerPin, HIGH)", "@dwbh" },
        { "digitalWrite(buzzerPin, LOW)", "@dwbl" },

        // LCD Object Creation and Setup
        { "LiquidCrystal_PCF8574 lcd(0x27);", "@lcd1" },
        { "lcd.begin(16, 2);", "@lcd2" },
        { "lcd.createChar(1, dotOff);", "@lcd3" },
        { "lcd.createChar(2, dotOn);", "@lcd4" },
        { "lcd.setBacklight(255);", "@lbl1" },
        { "lcd.setBacklight(0);", "@lbl0" },
        { "lcd.home();", "@lh" },
        { "lcd.clear();", "@lc" },
        { "lcd.print(\"", "@lp\"" },
        { "lcd.setCursor(", "@lsc" },
        { "lcd.cursor();", "@lcur" },
        { "lcd.blink();", "@lb" },
        { "lcd.noBlink();", "@lnb" },
        { "lcd.noCursor();", "@lnc" },
        { "lcd.noDisplay();", "@lnd" },
        { "lcd.display();", "@ld" },
        { "lcd.scrollDisplayLeft();", "@lsl" },
        { "lcd.scrollDisplayRight();", "@lsr" },
        { "Serial.println(\"LCD...\");", "@sp1" },
        { "Serial.println(\"Probing for PCF8574 on address 0x27...\");", "@sp2" },
        { "Serial.println(\": LCD found.\");", "@sp3" },
        { "Serial.println(\": LCD not found.\");", "@sp4" },
        { "Hello LCD", "@t1" },
        { "Cursor On", "@t2" },
        { "Cursor Blink", "@t3" },
        { "Cursor OFF", "@t4" },
        { "Display Off", "@t5" },
        { "Display On", "@t6" },
        { "*** first line.", "@t7" },
        { "*** second line.", "@t8" },

        // LCD Custom Character Data
        { "byte dotOff[] = { 0b00000, 0b01110, 0b10001, 0b10001,\n                  0b10001, 0b01110, 0b00000, 0b00000 };", "@dot1" },
        { "byte dotOn[] = { 0b00000, 0b01110, 0b11111, 0b11111,\n                 0b11111, 0b01110, 0b00000, 0b00000 };", "@dot2" },

        // I2C/Wire Commands
        { "Wire.begin();", "@wb" },
        { "Wire.beginTransmission(0x27);", "@wbt" },
        { "Wire.endTransmission();", "@wet" },

        // Comments PIR & buzzer
        { "// choose the input pin (for PIR sensor)", "@c1" },
        { "// we start, assuming no motion detected", "@c2" },
        { "// variable for reading the pin status", "@c3" },
        { "// Signal pin for the buzzer", "@c4" },
        { "// declare sensor as input", "@c5" },
        { "// Set buzzer pin as output", "@c6" },
        { "// read input value", "@c7" },
        { "// check if the input is HIGH", "@c8" },
        { "// we have just turned on", "@c9" },
        { "// we have just turned off", "@c10" },
        { "// Turn buzzer on", "@c11" },
        { "// Wait 4 seconds", "@c12" },
        { "// Turn buzzer off", "@c13" },
        { "// Wait 2 seconds", "@c14" },
        // Comments LCD
        { "// We only want to print on the output change, not state", "@c15" },
        { "// set the LCD address to 0x27 (TI chip) or 0x3F (NPX Chip)", "@c16" },
        { "// 2 custom characters", "@c17" },
        { "// wait on Serial to be available on Leonardo", "@c18" },
        { "// See http:", "@c19" },
        { "//playground.arduino.cc/Main/I2cScanner how to test for a I2C device.", "@c20" },
        { "//  initialize the lcd", "@c21" },


        // Control Flow & Whitespace
        { " else if ", "@ei" },
        { "while (", "@w(" },
        { "if (", "@i(" },
        { ") {", "}{" },
        { "} else {", "}e{" },
        { " {", "{" },
        { "{ ", "{" },
        { " }", "}" },
        { " ;", ";" },
        { ", ", "," },
        { ": ", ":" },
        { "\n\n", "\n" },
        { " // ", "//" }
    };


}